name: 'validate ops terraform'
# inits and validates ops terraform
#
on:
  pull_request:
    paths:
      - 'ops/terraform/**'

env:
  # default terraform version if no tools.yaml file(s) are found
  DEFAULT_terraform_version: '0.12.x'

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      run: ${{ steps.set-matrix.outputs.run }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}

    steps:
      - name: checkout repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 2
      - name: setup validation matrix
        id: set-matrix
        run: |
          # set -x
          
          # get a list of directories with changes and add to opsdirs.txt
          sort <(git diff --name-only --diff-filter=ACMRT HEAD^ HEAD | grep '.tf$') | xargs dirname | uniq > opsdirs.txt

          # subdirs returns a flattened, space seperated, list of sub-directories under $1 (not including $1)
          # $1 = path to a directory without trailing /
          subdirs(){
            find $(echo "$1") -mindepth 1 -maxdepth 1 -type d -exec echo {} +
          }

          # parses simple yaml files into variables. e.g., tools.yaml
          # terraform:
          #   version: 1.2
          # creates variable terraform_version=1.2
          # $! == path to yaml file
          function parse_yaml {
            # found this magic on stackoverlow
            local prefix=$2
            local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
            sed -ne "s|^\($s\):|\1|" \
                  -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
                  -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
            awk -F$fs '{
                indent = length($1)/2;
                vname[indent] = $2;
                for (i in vname) {if (i > indent) {delete vname[i]}}
                if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
                  printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
                }
            }'
          }

          # set_output expects the tf_environments array as an argument, it will parse, flatten, convert to json, and set the
          # outputs
          # $1 == tf_environments array
          set_output(){
            tf_environments="$1"

            # sort, flatten, and remove any duplicate environments
            environments=($(for e in "${tf_environments[@]}"; do echo "$e"; done | sort | uniq | xargs))
            
            # try getting terraform_version from ops/tools.yaml, else use default version
            terraform_version=
            eval $(parse_yaml ops/tools.yaml) || :
            if ! [[ "$terraform_version" =~ [0-9]?[0-9]+\.[0-9]?[0-9]+\.[0-9]?[0-9x]+ ]]; then
              terraform_version="$DEFAULT_VERSION"
            fi

            # prepare json output (github is very, very finicky on the formatting of json)
            # note: escape all quotes, collapse to one line, no trailing commas
            json="{\"include\":["
            json_lines=
            for((i=0;i<${#environments[*]};i++)); do
              json_lines+="{\"dir\": \"${environments[$i]}\",\"tfver\": \"${terraform_version}\"},"
            done
            # remove trailing ,
            json_lines="${json_lines%?}"

            # combine and output the results
            json="$json$json_lines]}"
            if [[ -n "${tf_environments[*]}" ]]; then
              echo "::set-output name=run::true"
              echo "::set-output name=matrix::$(echo "$json")"
            fi
          }

          ## BEGIN
          # flag environments to be validated by adding them to the tf_environments array
          # e.g., tf_environments+=("ops/terraform/env/prod/stateful")
          tf_environments=()

          # if there are any changes to module/resources, validate all the things
          if grep -E '^ops/terraform/modules/resources' opsdirs.txt >/dev/null 2>&1; then
            ## TODO: dynamically add all environments once we clean up dead code
            # for e in $(subdirs 'ops/terraform/env/*') ; do
            #   tf_environments+=("$e")
            # done
            # set_output "${tf_environments[@]}"
            # exit

            # for now, just validate the active environments
            for e in {prod,prod-sbx,test}; do
              for r in {stateless,stateful}; do
                tf_environments+=("ops/terraform/env/$e/$r")
              done
            done
          fi

          # validate global subdirectories (kms, s3, etc)
          globalre='^ops/terraform/env/global/(.*)+'
          if global_dirs=$(grep -E "$globalre" opsdirs.txt | cut -d/ -f 1-6 | uniq | xargs); then
            for e in "${global_dirs[@]}"; do
              tf_environments+=("$e")
            done
          fi

          # loop through all the environments and look for directories with changes
          for e in $(subdirs 'ops/terraform/env/*' | cut -f 1-5); do
            # add the env if there is a match
            if grep -E "^$e" opsdirs.txt >/dev/null 2>&1; then
              tf_environments+=("$e")
            fi
          done

          # loop through the various modules (ignoring resources) and validate as needed
          for m in $(subdirs 'ops/terraform/modules'); do
            if grep -E "^${m}" opsdirs.txt >/dev/null 2>&1; then
              # TODO: remove filters once we clean up dead code
              case "$m" in
                "ops/terraform/modules/stateful")
                  for e in {prod,prod-sbx,test}; do
                    tf_environments+=("ops/terraform/env/$e/stateful")
                  done
                ;;
                "ops/terraform/modules/stateless")
                  for e in {prod,prod-sbx,test}; do
                    tf_environments+=("ops/terraform/env/$e/stateless")
                  done
                ;;
                "ops/terraform/modules/mgmt_stateless")
                  echo "SKIPPING validations for $m"
                  #tf_environments+=("ops/terraform/env/mgmt/stateless")
                ;;
                "ops/terraform/modules/mgmt_stateful")
                  echo "SKIPPING validations for $m"
                  #tf_environments+=("ops/terraform/env/mgmt/stateful")
                ;;
                "ops/terraform/modules/migration")
                  for e in {prod,prod-sbx,test}; do
                    echo "SKIPPING validations for $m"
                    # tf_environments+=("ops/terraform/env/$e/migration")
                  done
                ;;
                "ops/terraform/modules/resources")
                  # skip
                  :
                ;;
                *)
                  echo "ERROR: new unhandled module group: $m"
                ;;
              esac
            fi
          done

          set_output "${tf_environments[@]}"


  validate:
    name:  validate terraform
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ needs.setup.outputs.run }}
    strategy:
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    defaults:
      run:
        working-directory: ${{ matrix.dir }}
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 1
      - uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: ${{ matrix.tfver }}
      - name: terraform init
        id: init
        run: terraform init -backend=false
      - name: terraform validate
        id: validate
        run: terraform validate -no-color
