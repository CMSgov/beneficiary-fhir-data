name: "Deploy Terraservice"
description: "Composite action to deploy a given Terraservice"
inputs:
  bfdEnvironment:
    description: "The BFD environment to deploy the given service to"
    required: true
  servicePath:
    description: "The path to the Terraservice relative to the root of the repository"
    required: true
  cloudwatchLogGroup:
    description: "Name of CloudWatch Log Group to submit Terraform logs to; must exist"
    required: true
  cloudwatchLogStream:
    description: "Name of CloudWatch Log Stream to submit Terraform logs to; will be created if necessary"
    required: true
  terraformVarsJson:
    description: "JSON object map of variables to their values"
    required: false
    default: "{}"
env:
  STDOUT_TO_CWLOGS_SCRIPT: "${{ github.workspace }}/.github/scripts/stdout-to-cwlogs.sh"
runs:
  using: "composite"
  steps:
    - name: Validate inputs
      run: |
        if [[ ! -d "${{ github.workspace }}/${{ inputs.servicePath }}" ]]; then
          echo "Directory '${{ inputs.servicePath }}' does not exist; has the BFD repo been checked-out?"
          exit 1
        fi
        # See https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CreateLogStream.html
        echo "${{ inputs.cloudwatchLogStream }}" | grep -Pv '[:*]'

        is_valid_log_group="$(
          aws logs describe-log-groups --log-group-name-pattern "${{ inputs.cloudwatchLogGroup }}" |
            jq -r '.logGroups != []'
        )"
        if [[ $is_valid_log_group == "false" ]]; then
          echo "'${{ inputs.cloudwatchLogGroup }}' does not exist; was the the correct Log Group specified?"
          exit 1
        fi
      shell: bash

    - name: Create Log Stream if needed and update env
      run: |
        # While the Log Group provided in the inputs is assumed to exist already, the Log Stream is
        # not. Attempt to create it, swallowing any error code that is returned and also capture
        # the stderr output so that it can be checked
        create_log_stream_stderr="$(
          aws logs create-log-stream --log-group-name "${{ inputs.cloudwatchLogGroup }}" \
            --log-stream-name "${{ inputs.cloudwatchLogStream }}" 2>&1 >/dev/null || true
        )"

        # If there was an error message logged by create-log-stream and that error was not
        # indicating that the Log Stream already exists (which is fine), then log that there was an
        # unrecoverable error and exit
        if [[ -n $create_log_stream_stderr && $create_log_stream_stderr != *"ResourceAlreadyExistsException"* ]]; then
          echo "Unrecoverable error occurred when trying to create Log Stream '${{inputs.cloudwatchLogStream }}' in Log Group '${{ inputs.cloudwatchLogGroup }}' ";
          echo "$create_log_stream_stderr"
          exit 1
        fi

        echo "'${{inputs.cloudwatchLogStream }}' in Log Group '${{ inputs.cloudwatchLogGroup }}' created or exists already"
        echo "Tail the Log Stream to view Terraform output in realtime"

        # Add the Log Group and Log Stream to the runner's environment
        echo "CLOUDWATCH_LOG_GROUP=${{ inputs.cloudwatchLogGroup }}" >> $GITHUB_ENV
        echo "CLOUDWATCH_LOG_STREAM=${{inputs.cloudwatchLogStream }}" >> $GITHUB_ENV
      shell: bash

    # Maps a given JSON object string of variable names to values, i.e.:
    # {
    #   "var1": "val1",
    #   "var2": 123,
    #   "var3": true
    # }
    # into a space-delimited argument list that the Terraform CLI understands:
    # -var=var1=val1 -var=var2=123 -var=var3=true
    - name: Generate Terraform vars args
      id: gen-tf-vars-args
      run: |
        tf_vars_args="$(
          echo "${{ inputs.terraformVarsJson }}" | jq -r 'to_entries |
            map(select(.value != null and .value != "")) |
            map("\"-var=" + .key + "=" + (.value | tostring)+ "\"") |
            join(" ")'
        )"
        echo "tf_vars_args=$tf_vars_args" >> $GITHUB_OUTPUT
      shell: bash

    - name: Check if tfvm is installed
      id: check-tfvm-installed
      run: |
        is_tfvm_installed="$([[ -x "$(command -v tfvm)" ]] && echo "true" || echo "false")"
        echo "is_tfvm_installed=$is_tfvm_installed" >> $GITHUB_OUTPUT
      shell: bash

    - name: Setup Terraform
      # Only install tfvm/Terraform if the current runner does not have tfvm installed
      if: steps.check-tfvm-installed.outputs.is_tfvm_installed == 'false'
      uses: cbuschka/setup-tfvm@v1

    - name: Terraform init
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"
        terraform --version
        terraform init -no-color
      shell: bash

    - name: Select Terraform workspace
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"
        terraform workspace new "${{ inputs.bfdEnvironment }}" 2> /dev/null || true &&\
        terraform workspace select "${{ inputs.bfdEnvironment }}" -no-color
      shell: bash

    - name: Generate Terraform plan
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"

        # Often the terraform plan logged to stdout as well as the errors logged to stderr include
        # sensitive/private information. GHA logs are available for anyone logged in with a GitHub
        # account to view, and so this information must be protected. Instead of logging to stdout,
        # all potentially sensitive Terraform log output is instead logged to CloudWatch
        echo "Generating Terraform plan for ${{ inputs.servicePath }}..."
        terraform plan ${{ steps.gen-tf-vars-args.outputs.tf_vars_args }} -no-color \
          -out=tfplan 2>&1 | "$STDOUT_TO_CWLOGS_SCRIPT"
        echo "Plan generated for ${{ inputs.servicePath }} successfully"
      shell: bash

    - name: Apply Terraservice
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"
        echo "Applying Terraform plan for ${{ inputs.servicePath }}..."
        terraform apply -no-color -input=false tfplan 2>&1 | "$STDOUT_TO_CWLOGS_SCRIPT"
        echo "Terraform plan for ${{ inputs.servicePath }} applied"
      shell: bash

    # Ensures that orphaned, background AWS PutLogEvents invocations from using
    # "stdout-to-cwlogs.sh" are able to complete before being cleaned-up by GHA
    - name: Await Terraform CloudWatch logging
      if: always()
      uses: ./.github/actions/await-cw-logging
