name: "Deploy Terraservice"
description: "Composite action to deploy a given Terraservice"
inputs:
  bfdEnvironment:
    description: "The BFD environment to deploy the given service to"
    required: true
  servicePath:
    description: "The path to the Terraservice relative to the root of the repository"
    required: true
  cloudwatchLogGroup:
    description: "Name of CloudWatch Log Group to submit Terraform logs to; must exist"
    required: true
  cloudwatchLogStream:
    description: "Name of CloudWatch Log Stream to submit Terraform logs to; will be created if necessary"
    required: true
  terraformVarsJson:
    description: "JSON object map of variables to their values"
    required: false
    default: "{}"
runs:
  using: "composite"
  steps:
    - name: Validate inputs
      run: |
        if [[ ! -d "${{ github.workspace }}/${{ inputs.servicePath }}" ]]; then
          echo "Directory '${{ inputs.servicePath }}' does not exist; has the BFD repo been checked-out?"
          exit 1
        fi
        # See https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CreateLogStream.html
        echo "${{ inputs.cloudwatchLogStream }}" | grep -Pv '[:*]'

        is_valid_log_group="$(
          aws logs describe-log-groups --log-group-name-pattern "${{ inputs.cloudwatchLogGroup }}" |
            jq -r '.logGroups != []'
        )"
        if [[ $is_valid_log_group == "false" ]]; then
          echo "'${{ inputs.cloudwatchLogGroup }}' does not exist; was the the correct Log Group specified?"
          exit 1
        fi
      shell: bash

    - name: Get Terraform logs file paths
      id: tf-logs-file-path
      run: |
        uuid="$(uuidgen)"
        raw_logs_path="${{ github.workspace }}/$uuid.raw.json"
        echo "raw_logs_path=$raw_logs_path" >> $GITHUB_OUTPUT
        processed_logs_path="${{ github.workspace }}/$uuid.processed.json"
        echo "processed_logs_path=$processed_logs_path" >> $GITHUB_OUTPUT
      shell: bash

    # Maps a given JSON object string of variable names to values, i.e.:
    # {
    #   "var1": "val1",
    #   "var2": 123,
    #   "var3": true
    # }
    # into a space-delimited argument list that the Terraform CLI understands:
    # -var=var1=val1 -var=var2=123 -var=var3=true
    - name: Generate Terraform vars args
      id: gen-tf-vars-args
      run: |
        tf_vars_args="$(
          echo "${{ inputs.terraformVarsJson }}" | jq -r 'to_entries |
            map(select(.value != null and .value != "")) |
            map("\"-var=" + .key + "=" + (.value | tostring)+ "\"") |
            join(" ")'
        )"
        echo "tf_vars_args=$tf_vars_args" >> $GITHUB_OUTPUT
      shell: bash

    - name: Check existing Terraform version
      id: check-tf-version
      run: |
        cur_version="NONE"
        if [[ -x "$(command -v terraform)" ]]; then
          # Terraform emits multiple unnecessary lines when running "terraform --version" indicating
          # the OS, arch, whether Terraform is out-of-date, etc. We don't care about anything but
          # the version, so the grep matches on the version number and returns only the match
          cur_version="$(terraform --version | grep -Po "(?<=Terraform v)(.*)$")"
        fi
        echo "cur_version=$cur_version" >> $GITHUB_OUTPUT
      shell: bash

    # - name: Get required Terraform version
    #   uses: dflook/terraform-version@v1
    #   id: terraform-version
    #   with:
    #     path: ${{ github.workspace }}/${{ inputs.servicePath }}

    - name: Setup Terraform
      # Only install Terraform if the current runner does not have the expected version of Terraform
      # installed already
      # if: steps.check-tf-version.outputs.cur_version != steps.terraform-version.outputs.terraform
      # if: steps.check-tf-version.outputs.cur_version != "NONE"
      # uses: hashicorp/setup-terraform@v3
      uses: cbuschka/setup-tfvm@v1
      # with:
      #   terraform_version: ${{ steps.terraform-version.outputs.terraform }}
      #   # No subsequent jobs require the output of the Terraform commands, so we can stip installing
      #   # the wrapper that sets the "stdout", "stderr", etc. outputs on steps running Terraform
      #   terraform_wrapper: false

    - name: Terraform init
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"
        terraform --version
        terraform init -no-color
      shell: bash

    - name: Select Terraform workspace
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"
        terraform workspace new "${{ inputs.bfdEnvironment }}" 2> /dev/null || true &&\
        terraform workspace select "${{ inputs.bfdEnvironment }}" -no-color
      shell: bash

    - name: Generate Terraform plan
      run: |
        cd "${{ github.workspace }}/${{ inputs.servicePath }}"

        # Often the terraform plan logged to stdout as well as the errors logged to stderr include
        # sensitive/private information. GHA logs are available for anyone logged in with a GitHub
        # account to view, and so this information must be protected. Instead of logging to stdout,
        # all potentially sensitive Terraform log output is transformed into a format CloudWatch
        # Logs understands and appended to a temporary file. These logs are then uploaded at the
        # end of this action, regardless of success or failure
        echo "Generating Terraform plan for ${{ inputs.servicePath }}..."
        terraform plan ${{ steps.gen-tf-vars-args.outputs.tf_vars_args }} -no-color -out=tfplan &> >(
          while read line; do
            echo "$(
              jq -n \
                --arg unix_ts "$(date +%s%3N)" \
                --arg line "$line" \
                '{ "timestamp": ($unix_ts | tonumber), "message": ($line | tostring) }'
            )" >> "${{ steps.tf-logs-file-path.outputs.raw_logs_path }}"
          done
        )
        echo "Plan generated for ${{ inputs.servicePath }} successfully"
      shell: bash

    # TODO: Uncomment
    # - name: Apply Terraservice
    #   run: |
    #     cd "${{ github.workspace }}/${{ inputs.servicePath }}"
    #     echo "Applying Terraform plan for ${{ inputs.servicePath }}..."
    #     terraform apply -no-color -input=false tfplan &> >(
    #       while read line; do
    #         echo "$(
    #           jq -n \
    #             --arg unix_ts "$(date +%s%3N)" \
    #             --arg line "$line" \
    #             '{ "timestamp": ($unix_ts | tonumber), "message": ($line | tostring) }'
    #         )" >> "${{ steps.tf-logs-file-path.outputs.raw_logs_path }}"
    #       done
    #     )
    #     echo "Terraform plan for ${{ inputs.servicePath }} applied"
    # shell: bash

    # This step uploads the potentially sensitive Terraform log output from previous steps to
    # CloudWatch Logs so that BFD Engineers can still inspect the output without fear of that
    # potentially sensitive information being exposed publicly
    - name: Submit Terraform logs to CloudWatch
      # Run regardless of prior step outcome
      if: always()
      run: |
        if [[ -z "${{ steps.tf-logs-file-path.outputs.raw_logs_path }}" || ! -f "${{ steps.tf-logs-file-path.outputs.raw_logs_path }}" ]]; then
          echo "No logs to submit to CloudWatch"
          exit
        fi

        # While the Log Group provided in the inputs is assumed to exist already, the Log Stream is
        # not. Attempt to create it, swallowing any error code that is returned and also capture
        # the stderr output so that it can be checked
        create_log_stream_stderr="$(
          aws logs create-log-stream --log-group-name "${{ inputs.cloudwatchLogGroup }}" \
            --log-stream-name "${{ inputs.cloudwatchLogStream }}" 2>&1 >/dev/null || true
        )"

        # If there was an error message logged by create-log-stream and that error was not
        # indicating that the Log Stream already exists (which is fine), then log that there was an
        # unrecoverable error and exit
        if [[ -n $create_log_stream_stderr && $create_log_stream_stderr != *"ResourceAlreadyExistsException"* ]]; then
          echo "Unrecoverable error occurred when trying to create Log Stream '${{inputs.cloudwatchLogStream }}' in Log Group '${{ inputs.cloudwatchLogGroup }}' ";
          echo "$create_log_stream_stderr"
          exit 1
        fi

        # Process the "raw" JSON logs from each Terraform invocation into an array of non-empty
        # log events that CloudWatch understands
        jq -s '. | map(select(.message != ""))' "${{ steps.tf-logs-file-path.outputs.raw_logs_path }}" > \
          "${{ steps.tf-logs-file-path.outputs.processed_logs_path }}"
        # Submit the "processed" logs file to CloudWatch. Capture stdout and ignore it
        aws logs put-log-events --log-group-name "${{ inputs.cloudwatchLogGroup }}" \
          --log-stream-name "${{ inputs.cloudwatchLogStream }}" \
          --log-events "file://${{ steps.tf-logs-file-path.outputs.processed_logs_path }}" 1>/dev/null

        echo "Terraform logs put to Log Group '${{ inputs.cloudwatchLogGroup }}' in Log Stream '${{ inputs.cloudwatchLogStream }}'"
      shell: bash
