# RFC Proposal
[RFC Proposal]: #rfc-proposal

* RFC Proposal ID: `0020-rotate-hash-peppers`
* Start Date: 2023-08-21
* RFC PR: [beneficiary-fhir-data/rfcs#0020](https://github.com/CMSgov/beneficiary-fhir-data/pull/1642)
* JIRA Ticket(s):
    * [BFD-1110](https://jira.cms.gov/browse/BFD-1110)

BFD maintains hashed MBI and hashed HICN values to facilitate FHIR patient search for a beneficiary; every beneficiary's hashed values are persisted in the BFD database and can handle both current as well as historical MBI and HICN values. 

The hashing algorithm, and all criteria necessary to create a matching hashed value, is shared with peering partners; this allows them to construct obfuscated MBI or HICN hash values that can then be safely used within an HTTP GET URL parameter(s) accessing the BFD patient search endpoint.

This RFC is therefore intended to explore solutions that lend themselves to providing continued access to BFD patient search functionality with minimal to zero downtime due to either diminished access to BFD services or imposing undue work required of BFD clients (hereafter referred to as Peering Partners or PPs).

## Status
[Status]: #status

* Status: Propsed <!-- (Proposed/Approved/Rejected/Implemented) -->
* Implementation JIRA Ticket(s):
    * [BFD-1110](https://jira.cms.gov/browse/BFD-1110)

## Table of Contents
[Table of Contents]: #table-of-contents

* [RFC Proposal](#rfc-proposal)
* [Status](#status)
* [Table of Contents](#table-of-contents)
* [Motivation](#motivation)
* [Definitions](#definitions)
* [Background](#background)
  * [Current Patient Search](#current-patient-search)
  * [BFD Hash Algorithm](#bfd-hash-algorithm)
  * [Much Ado About Nothing](#much-ado-about-nothing)
* [Exploration of Solutions](#exploration-of-solutions)
  * [Status Quo](#status-quo)
  * [Hot Stand-by : Option 1](#hot-standby-1)
  * [Hot Stand-by : Option 2](#hot-standby-2)
  * [HTTP POST](#http-post)
  * [Asymmetric Crypto](#asymmetric-crypto)
* [Proposed Solution: Detailed Design](#proposed-solution-detailed-design)
  * [Proposed Solution: Unresolved Questions](#proposed-solution-unresolved-questions)
  * [Proposed Solution: Drawbacks](#proposed-solution-drawbacks)
  * [Proposed Solution: Notable Alternatives](#proposed-solution-notable-alternatives)
* [Prior Art](#prior-art)
* [Future Possibilities](#future-possibilities)
* [Addenda](#addenda)

## Motivation
[Motivation]: #motivation
BFD provides a FHIR (STU3, R4) patient search service in which a Peering Partner (PP) can lookup a patient using either a patient's Medicare Beneficiary ID (MBI) or the less used patient Health Insurance Claim Number (HICN).

The current BFD patient search service is implemented as an HTTP GET which requires an identifier, such as a patient's MBI or HICN, to be obfuscated prior to being used within a URL GET parameter. To achieve this, a level of syncrhronicity must be maintained between a PP and BFD; in a nutshell, BFD shares a hashing algorithm, including seed value and iteration count, with PPs such that a PP can create/embed a hashed value in a URL, which can then be used by the BDF service to search for a match in the database. This symmetric key/algorthim sharing, if compromised, creates an attack vector for accessing a patient's PII/PHI data.

This RFC then explores ways to preserve the patient search functionality in a manner that minimizes, or completely eliminates BFD services downtime, especially in a leaked key (algorithm) scenario.

## Definitions
[Definitions]: #definitions
##### TLS
 Transport Layer Security, and its predecessor, Secure Sockets Layer (SSL), both frequently referred to as SSL, are cryptographic protocols that provide communications security over a computer network; the connection is private (or secure) because symmetric cryptography is used to encrypt the data transmitted.
 ##### Peering Partner (PP)
 A Client of BFD services is commonly referred to as _peering partner_. BFD currently supports the following PPs:
 - AB2D
 - BCDA
 - DPC
 - BB2
 ###### Symmetric Cryptography
 Symmetric cryptography is a system of encryption where the same key is used to both encrypt and decrypt data. It is generally faster than asymmetric cryptography but is generally **considered less secure since the same key must be shared among all users**.
 ###### Asymmetric Cryptography
 Asymmetric cryptography is a type of encryption that uses two different keys to encrypt and decrypt data. Using a public-private keypair, anyone with the public key can send an encrypted message to the owner of the private key, who can then use the associated private key to decrypt it. The reciprocal is also true; private key holder can create an encrypted message, that holders of the public key can decrypt.

## Background
[Background]: #background
### Current Patient Search
[Current Patient Search]: #current_patient_search
Prior to delving into proposed strategies or solutions, it is best to provide some context on how things currently work, and the challenges and constraints BFD currently faces.
- BFD maintains a hashing algothim that is used to create a hashed value of a patient's MBI and/or HICN.
- BFD shares with its peering partners all components of the hashing algorithm, including the base algorithm, a seed value (salt) and an iteration count.
- PPs request patient information by invoking a BFD _patient search_ RESTful service (HTTP GET) that requires an obfuscated (hashed) patient identifier as a URL parameter.
- BFD service extracts the provided patient identifier and performs one or more database lookups to derive the patients primary key identifier (BENE_ID).
  - it first checks the _BENEFICIARIES_HISTORY_ table for a match (either MBI_HASH or BENE_CRNT_HIC_NUM); found value(s) are added to an internal list.
  - it then checks the _BENEFICIARIES_ table for a match (either MBI_HASH or BENE_CRNT_HIC_NUM); found value(s) are added to a list. The _BENEFICIARIES_ table holds current value for a hashed MBI and a hashed HICN value.
  - the list of hashed values is then traversed resulting in either a hit (code now has a BENE_ID) or no match (HTTP search returns NOT FOUND)
- One thing to note for _patient search_, is BFD's continued support for a HICN identifier; this requires BFD to maintain an indexed hash value for every patient which not only doubles a potential attack vector, but also costs real dollars in terms of database storage and index costs. As background, the _New Medicare Card Project_ was established in the _Medicare Access and CHIP Reauthorization Act (MACRA) of 2015_ which mandates the removal of the Social Security Number-based Health Insurance Claim Number (HICN) from Medicare cards by April, 2019. Beginning in January 2020, providers may only use MBIs, with very limited exception. Removing support for HICN-based lookups would halve the work required for re-hashing lookup values since only MBI would need to be done.
- Maintaining hashed MBI and HICN data represents functionality distinct to:
  - a single BFD service, _patient search_ (HTTP GET). 
  - PACA lookups, which should only support hashed MBI values
### BFD Hash Algorithm
[BFD Hash Algorithm]: #bfd_hash_algorithm
In broad terms, BFD uses a cryptographically sound, one-way hashing algorithm, that leverages additional best practices to produce an obfuscated base-64 encoded character string. The entire hash-generation process is shared amongst all BFD peering partners, allowing each PP to dynamically generate an obfuscated patient identifier suitable for use as a patient identifier to perform a patient lookup. For example, a PP could take an MBI value, hash that, and then request information on that patient using the hashed MBI. Because BFD defines, and subsequently shares all aspects of the hashing algorithm, this could be deemed a security issue if the algorithm is leaked.
### Much Ado About Nothing?
[Much Ado About Nothing]: #much-ado-about-nothing
Is the leakage of BFD's hashing algorithm, really a security concern? Depends. Let's explore that by assuming that the algorithm is leaked into the wild:
1. BFD is a closed system, requiring mTLS authentication; essentially BFD has a known set of clients (peering partners) that use an X509 certificate to connect to BFD. BFD server checks that client certificate vs. a known list of certificates that reside in the BFD server _trust store_; so a client must be a known entity just to connect.
2. While all BFD clients are known, BFD does not support role-based authentication or authorization; this means that all clients have equal access to any beneficiciary info regardless if that client reallly has no business accessing a given beneficiary's data.
3. Hashed patient identifiers are simply one way to _search for_ patient information; but there are other paths to achieve the same. For example, BFD supports the fetching of BENE_ID values based on a Part D contract identifier; those part D contract IDs are not considered PII/PHI data, so a simple request to fetch all patients for a contract ID, yields a list of identifiers (BENE_ID) that are even more useful than a hashed MBI value. With a BENE_ID in hand, pretty much any and all BFD data for a patient could be harvested.
4. The BFD hashing algorithm is made up of the base algorithm, a _salt_ value (referred to as _pepper_ in BFD parlance), and an iteration count. A cleartext _key_, in this case a patient identifier (i.e., MBI), is fed into the alg, resulting in a hashed value; so in order to create the hashed identifier, a bad actor would need to know a patient's MBI. So if they already know the MBI value, and all the hashing does is obfuscate that MBI value, then a leaked algorithm, accessing a closed system that is restricted to known peering partners may not be that big a problem.
5. Where the hash leak does become relevant, is if an attacker knows a patient MBI and the hashing algorithm; in that case they can generate a hashed MBI and pass that to search services that require a hashed MBI; that is if they can even connect to BFD (see item 2 above).
### So We Leaked the Hash Algorithm
Prior to delving into possible solutions, and more germane to this RFC, some background on how BFD currently might handle a leak of the algorithm that both BFD and peering partners share.

To start with, BFD has never encountered the situation where a leaked component of the hashing alogritm would require immediate mitigation; there have been some muted table-top and/or game-day exercises, but nothing concrete and for real. So what follows is some back-of-the-napkin tasks that would need to be completed in the current environment in such a scenario.
- incident declared denoting hashing algorithm is compromised; depending on the severity of the leak (i.e., how long has it been compromised, etc.) may dictate the severity of the incident.
- BFD services may not need to be taken offline; the hashing algorithm is used by a couple of BFD services; those service calls takes an MBI or HICN hash parameter; for example (cURL syntax):
```
identifier="https://bluebutton.cms.gov/resources/identifier/hicn-hash|6026b9c1f00ba3937a8876f909c1c0d806d36229111e030ab867a8fc91792851"
or
identifier="https://bluebutton.cms.gov/resources/identifier/mbi-hash|1425547895d49fdf40d4128ec03cfd53c6ca2a67af9f7adcc2845a00cf6a5af5"
```
- need to change components of the (leaked) hashing algorithm; the changes would most likely be constrained to the seed and/or iteration count. The new hash algorithm components would be persisted in the BFD SSM parameter store.
- peering partners need to be alerted to the issue and pendinghashing  mitigation plan; changing the algorithm will require communicating the new hashing algorithm via an agreed upon secure channel. Since this affects all PPs, some amount of collaboration and synchronization of PPs will need to be implemented.
- need to update all records in the _BENEFICIARIES_ table (67M+ records) with new MBI and HICN hash values using the newly minted hashing algorithm being applied to the bene's plaintext MBI and HICN table columns. The hashing of a field is compute intensive and time consuming; since both hashed columns are also indexed in the table, the database update operation will take some time. There are database optimzation techniques we employ for this operation (i.e., drop indexes, perform updates, rebuild indexes) but we have no prior work that defines best practices for this type of update.
- The above database update presents an interesting conumdrum; in theory, BFD should have in its toolchest, a simple program (script) that reads/updates the hashed identifiers in every record in the _BENEFICIARIES_ table; in addition a runbook would exist denoting best practices for an operation of this kind.
- once the 67+ million _BENEFICIARIES_ records have been updated and indexed, BFD could perform a deployment with the new hashing algorithm at the ready and the database fully compliant with the hashing changes.
- Peering Partners would then need to modify how they construct (or cache) their instance of the BFD hashing algorithm. Once deployed, BFD could return servicing requests and it would be up to each PP to implement their necessary changes to comply with the new hashing algorithm.
- Weekly ETL processing
  - ETL performs hashing of MBI and HICN value(s) at time of INSERT into _BENEFICIARIES_ table.
  - ETL performs re-hashing of MBI and HICN value(s) when detecting a changed MBI or HICN value during an UPDATE to a current _BENEFICIARIES_ table record.

 ### Peering Partner (PP) Usage - Patient Search
 The following list of _peering partners_ provides information as to if and how a PP may be affected by changes to the BFD hash algorithm:
 - AB2D - do not use hashed MBI or HICN; only BENE_ID
 - BCDA
   - dynamically calculate the hashed MBI when building the URL using the hash pepper and iterations (environment variables)
   - may need code changes (if the alg changes) and may require some maintenance window to switch over to the new seed/iteration count.
   - Don't call _patient search_ all that often; only when they want to confirm they have right patient. 
 - DPC
   - Only use hashed MBI; never HICN
   - have a _hashed MBI_ field in their attribution database, but it's not being used.
   - calculate hash in realtime as each call is made.
   - hash algorithm is abstracted away pretty well; If need to change anything it should only be a few lines of code in one place, so not a big impact.
 - BB2
   - dynamically calculate the hash values for MBI to be used to match an enrollee via the Patient search.
   - seed/iteration settings are loaded when the server is deployed; need downtime and a re-deployment to switch those values out.
   - they recall updating their codebase to handle cases where cleartext MBI or HICN values change for enrollees that are already in the _BB2 Crosswalk_ table.
   - Previous to doing this, occasionally run into cases where enrollee MBI would get changed and auths would fail for them.
   - Currently new hashes that match in a patient search will get replaced when the enrollee re-authorizes
   - used HICN lookups sporadically (when MBI failed); mainly limited to synthetic bene(s); 
## Exploration of Solutions
[Exploration of Solutions]: #exploration-of-solutions

This section explores five potential strategies for dealing with a required change to BFD's hashing algorithm.
### Status Quo
[Status Quo]: #status-quo

Currently, if BFD needs to change the hashing algorithm, it may require some sort of maintenance window and/or minor performance degradation. The current data and the services logic is not capable of handling more than a single instance of the hashing algorithm and a single tuple of a hashed MBI and hashed HICN within each patient record (_BENEFICIARIES_ table). However, there are some simple mechanisms that could be used to at least minimize any downtime.

Since we have no existing _Runbook_ and have no significant work specific to replacing the hash algorithm, the following (rough) pseudo-code steps might be executed in an emergency situation:

- define a new hash algorithm; most likely modify salt (seed value) and/or iteration count (or both). The algorithm construct will need to be communicated to all peering partners in a secure message exchange prior to plan execution and subsequent synchronization of a _go-live_ date at which time BFD would only support newly updated hash values.

- create a new instance (a copy) of the _BENEFICIARIES_ table; say _BENEFICIARIES_PREHASH_; for example, in a flyway script (or possibly out-of-band):
```
CREATE BENEFICIARIES_PREHASH AS
  SELECT * FROM BENEFICIARIES;
```
- create and execute a script (python? SQL?) that would:
  - sequentialy read/update each record in the new table
  - for each record, calculate new hash value for _MBI_HASH_ and _BENE_CRNT_HIC_NUM_ by hashing respective cleartext columns:
     - hash _MBI_NUM_ to create _MBI_HASH_ value
     - hash _HICN_UNHASHED_ to create _BENE_CRNT_HIC_NUM_ 
  - update (persist) the record
  - create index for _MBI_HASH_; TBD if we even want/need to create index on _BENE_CRNT_HIC_NUM_.
```
CREATE INDEX IF NOT EXISTS beneficiaries_prehash_mbi_idx
    ON BENEFICIARIES_PREHASH
    (mbi_hash);

// If we need support for hashed HICN
CREATE INDEX IF NOT EXISTS beneficiaries_prehash_hicn_idx
    ON BENEFICIARIES_PREHASH
    (bene_crnt_hic_num);
```
- alert peering partners of scheduled (date-time) maintenance window, at which time the new hash values will be enabled in each environment:
  - Perform database table rename operations:
```
alter table BENEFICIARIES rename to BENEFICIARIES_ORIG;
alter table BENEFICIARIES_PREHASH rename to BENEFICIARIES;
```
  - Perform database indeces rename operations:
```
ALTER INDEX beneficiaries_mbi_idx
  RENAME TO beneficiaries_orig_mbi_idx;

ALTER INDEX beneficiaries_hicn_idx
  RENAME TO beneficiaries_orig_hicn_idx;

// rename indeces we originally created in the _prehash_ table
ALTER INDEX beneficiaries_prehash_mbi_idx
  RENAME TO beneficiaries_mbi_idx;

// if we need continued support hashed HICN lookups
ALTER INDEX beneficiaries_prehash_hicn_idx
  RENAME TO beneficiaries_hicn_idx;
```
- SQL renames are generally extremely fast so the above ALTER statements would complete in seconds.
- Once db changes are complete, the BFD database is effectively operational but a deployment would still be required to ensure ETL is updated with the new hash algorithm.
- Peering partners requiring patient search would remain _broken_ until they have synchronized their codebase/processing with the updated hashing algorithm.
- If the PP is not using the latest hashing algorithm, and BFD has updated its database and algorithm, or vice versa the PP has updated its hashing algorithm but BFD has not yet finished updating the  _BENEFICIARIES_ table, then _patient search_ requests will return an empty result Bundle.
- Some permutations of the above UPDATE logic/processing steps, for which BFD does have prior work, is to wrap the _BENEFICIARIES_ table in an updateable db VIEW, and then toggle between two _BENEFICIARIES_ tables simply by (re-) pointing the VIEW as needed.

**NOTE** - while this document may reference database tables, columns, indexes, etc. it should be noted that any processing changes that affect a database, needs to occur in three distinct environments: _PROD_, _PROD-SBX_ and _TEST_.
#### PROS
- minor impact on BFD; basically the time to create/update the _new_ _BENEFICIARIES_PREHASH_ table (or some similar approach) and build indexes on hashed columns.
- minor impact to PP; they will need to modify their pre-request URL construction to use the new hash algorithm.
- minor impact to ETL processing (depends on when the operation needs to be implemented).
- since not operating on a current production table (_BENEFICIARIES_), db optimization techniques could be applied without impacting current production.
- bordering on the _do nothing_, but certainly KISS (keep it simple...)
#### CONS
- while not quite _zero downtime_ this tack is the closest what could be achieved based on current capabilities; does not represent a significant level of effort to implement.
- will need write script (i.e., python, SQL) that can re-hash records and update db table.
### Hot Stand-by : Option 1
[Hot Stand-by - Option 1]: #hot-standby-1
The premise behind a _hot stand-by_ is to have BFD actively support multiple concurrent hash algorithms and associated _MBI_HASH_ and _BENE_CRNT_HIC_NUM_ values specific to each hash algorithm that was used to generate the hash values.

This set of _shadow_ values for MBI and HICN could be accomplished solely within the _BENEFICIARIES_ data (i.e., maintain two sets of hashed values). Since the bulk of the (performance) cost for a hash value is the hashing operation itself, we could probably not worry about indexing the new fields; they exist as already calculated hash values which will be plugged into the the real hash columns (_MBI_HASH_ and _BENE_CRNT_HIC_NUM_) with a single SQL update script as needed.

 A rough outline of functionality might look like:
```
ALTER TABLE BENEFICIARIES
   ADD COLUMN mbi_hash_standby CHARACTER VARYING(64),
   ADD COLUMN bene_crnt_hic_num_standby CHARACTER VARYING(64);
```
- the _BENEFICIARIES_ table thus contains 2 sets of MBI and HICN data columns
  - MBI_HASH
  - BENE_CRNT_HIC_NUM
  - MBI_HASH_STANDBY
  - BENE_CRNT_HIC_NUM_STANDBY
- some sort of script (python, SQL) could then update the _STANDBY columns using the new hash algorithm.
- when necessary to make the _STANDBY values _active_; a SQL script could be executed to do that; something like:
```
UPDATE BENEFICIARIES SET
  mbi_hash = mbi_hash_standby,
  bene_crnt_hic_num = bene_crnt_hic_num_standby
    WHERE bene_id EXISTS
      AND MBI_HASH_STANDBY IS NOT NULL;
```
#### PROS
- minimal changes to current processing
  - standby columns need to be added to ORM
  - some script work (python or SQL)
- minor impact to PP; they will need to modify their pre-request URL construction to use the new hash algorithm so it would be presumptuous to consider this a _zero downtime_ solution.
#### CONS
- same table UPDATE, INDEXES introduces some challenges; may need to re-build index concurrently which can be slower than having table locked for indexing which is feasible, as noted in the prior use case using a separate _BENEFICIARIES_PREHASH_ table.
- maintaining data over time (i.e., INSERTs or UPDATEs from weekly ETL) needs to be considered; changes to ETL may be non-trivial.
- may also require some AWS (SSM) work
- will need script (i.e., flyway, python, SQL) that can populate new table columns; possibly custom maven build artifact.
### Hot Stand-by : Option 2
[Hot Stand-by - Option 2]: #hot-stand-by-2

Similar to Option 1, but maintain the _shadow_ values for MBI and HICN in a (new) separate table.

 A rough outline of functionality might look like:
- SSM parameter store upgraded to support multiple hash algorithm instances:
  - SSM hash alg key
  - SSM hash alg salt (seed value)
  - SSM hash alg iteration count
  - SSM hash alg status (active, future, disabled)
- create table for storing concurrent beneficiary hash values; a sample table structure might look like:
```
CREATE TABLE IF NOT EXISTS hashed_beneficiaries
(
    id                bigint NOT NULL,
    ssm_param_id      character varying(32) NOT NULL,
    bene_id           bigint NOT NULL,
    bene_crnt_hic_num character varying(64) NOT NULL,
    mbi_hash          character varying(64),
    efctv_end_dt      date,
    CONSTRAINT hashed_beneficiaries_pkey PRIMARY KEY (id)
);

CREATE INDEX IF NOT EXISTS hashed_beneficiaries_ssm_bene_id_idx
    ON hashed_beneficiaries USING btree (ssm_param_id, bene_id);

CREATE INDEX IF NOT EXISTS hashed_beneficiaries_mbi_hash_idx
    ON hashed_beneficiaries USING btree (mbi_hash);
    
CREATE INDEX IF NOT EXISTS hashed_beneficiaries_crnt_hic_num_idx
    ON hashed_beneficiaries USING btree (bene_crnt_hic_num);
```
- the table could hold multiple records per beneficiary, thereby supporting multiple hash algorithms and associated values for _MBI_NUM_ and _BENE_CRNT_HIC_NUM_
- Depending on usage analysis, a db constraint could be defined such that a relationship exists linking the new table to the _BENEFICIARIES_ table; this relationship would allow for _BENEFICIARIES_ data to be fetched as part of a fetch of a given _HASHED_BENEFICIARIES_ record.
  - records with a non-null _EFCTV_END_DT_ could be used to filter out only those records that are still marked as active.
#### PROS
- would allow BFD services to minimize downtime by having new hash algorithm and associated hashed fields at the ready. 
- minor impact to PP; they will need to modify their pre-request URL construction to use the new hash algorithm so it would be erroneous to consider this a _zero downtime_ solution.
- this option might be more acceptable if the necessity for changing the hashing algorithm becomes a constant timely operation (i.e., we need to change the hashing alg every 90 days).
#### CONS
- LOE for implementing db schema changes (new table).
- maintaining data over time (i.e., INSERTs or UPDATEs from weekly ETL)
- will need some AWS (SSM) work
- will need script (i.e., python) that can populate new db table; probably custom maven build artifact.
### HTTP POST
[HTTP POST]: #http-post

The necessity for maintaining hashed MBI and HICN values is a function of implementing a couple of BFD services, as a HTTP GET(s), which, by definition, requires parameter values to be provided as part of the URL. This means, that both MBI and/or HICN raw values must be obfuscated since URLs are logged for every BFD request; those logs then become accessible in multiple downstream outlets such as AWS CloudWatch and Splunk. 

The FHIR spec (STU3, R4, R5) for a patient search, supports both GET and POST operations (see https://hl7.org/fhir/STU3/search.html).
- GET  [base]/[type]?name=value&...{&_format=[mime-type]}}
   - parameters are a series of name=[value] pairs encoded in the URL (GET)
- POST [base]/[type]/_search{?[parameters]{&_format=[mime-type]}}
   - parameters are a series of name=[value] pairs encoded as an application/x-www-form-urlencoded submission 

Since all BFD services are protected by TLS, changing a service from a GET to a POST operation, by definition, precludes visibility to any data encoded in the POST body. In effect, this removes entirely the necessity to even support/maintain hash values for MBI and HICN.
#### PROS
- **completely removes necessity to have/maintain hash algorithms and hashed data values**; BFD would never have to deal with this issue again.
- removing requirement for PPs to hash search params simplifies URL construction for their client implementation and provides immediate performance boost due to not having to created hashed lookup value.
- in checking with PPs, they are unamimous that this would be a good idea IF BFD could support both GET and POST for patient search for some minimal overlap duration, at the end of which, support for GET could be removed. Using raw MBI_NUM allows PPs to streamline their processing and not worry about hashing algorithm.
#### CONS
- BFD would need to implement some sort of logging interceptor of POST operations if we wanted to maintain current logging visibility for requests. Under the current logging framework, the GET URL is logged which includes the search param; BFD would lose visibility to the MBI or HICN hashed param value that is currently captured in log files. A logging interceptor could mitigate this shortcoming.
- PPs that currently use service GET URLs will need to modify their client setup code to use HTTP POST; this requires the following changes:
  - change construction of URL from GET to POST.
  - encode former GET params into a POST body.
- PPs are in favor of POST if some overlap support / break-in period supprting both GET and POST.
### Asymmetric Crypto
[Asymmetric Crypto]: #asymmetric-crypto

As noted previously, distributing a shared hashing algorithm to peering partners is effectively implementing symmetric crypto; so while BFD can take great care in protecting the hashing algorithm, we do not maintain exclusive access over it. So while we have faith in our clients (peering partners) protecting the algorithm, we effectively have minimal control over how it is handled (protected) once it leaves our domain.

If BFD wishes to maintain total control over hashing of URL GET parameters, we could adopt asymmetric crypto for creating the hash value(s). Instead of _sharing_ a secret (the algorithm), we use a public-private keypair to dynamically encrypt/decrypt sensitive URL parameters.

BFD creates a public-private keypair; it then distributes the public key to each of its peering partners. Each PP then uses their copy of the public key to encrypt a plaintext MBI or HICN; the encrypted value is then passed to the BFD _patient search_ as a URL GET parameter. The parameter is fully obfuscated so any public access (logging, TCP snooping, etc.) is limited to just that...a URL that has an encrypted content and the only way to discern the view the sensitive parameter is to decryypt it using BFD's private key.
#### PROS
- can still support HTTP GET URLs; current logging continues as is, logging the URL.
- extensible choice of algorithms and key sizes make this the safest way to protect data.
- wide range of algorithms and keysizes make this extremely extensible and bullet-proof.
- already using asymmetric in our TLS implementation.
- completely removes necessity to have/maintain hash algorithms and hashed data values; completely removes necessity to store hashed data (_MBI_HASH_ and _BENE_CRNT_HIC_NUM_ values); lookups now occur vs. actual _MBI_NUM_ or HICN_UNHASHED_ value.
#### CONS
- slight overkill for what BFD needs.
- feeling performance will take a hit, but this can be mitigated by using Elliptical Curve Cryptograph (ECC) which provides better performance by using smaller keysizes which are just as resilient as RSA that depends on larger keysizes.
- small learning curve for some devs, but BFD implementation would not be complex.

### Proposed Solution: Detailed Design
[Proposed Solution: Detailed Design]: #proposed-solution-detailed-design

1. In the spirit of KISS (keep it simple, stupid), the proposal here is to do a staged migration away from supporting HTTP GET for the _patient search_ service. This accomplishes the goal of this RFC, which is to determine the best way to handle the ongoing maintenance of hashed MBI and/or HICN values; it accomplishes this, by simply eliminating the necessity to support/maintain hashed MBI and HICN values in a BFD data store, in a manner that complies with all versions of the FHIR specification and embraces HTTP best practices for handling data requests that contain sensitive data.
2. The intent is to support both HTTP GET and HTTP POST _patient search_, for a limited period of time (TBD); this strategy provides peering partners an on/off ramp for removing their current use of HTTP GET with a new functionally equivalent HTTP POST that BFD will introduce for both STU3 and R4 endpoint(s).
3. The current _patient search_ is implemented in:
  - STU3 : PatientResourceProvider.java
  - R4   : R4patientResourceProvider.java
Both STU3 and R4 of the current implementaion effectively operate in the same fashion:
  a) validate the input parameters; throw exceptions when appropriate.
  b) check the _LoadedFilterManager_ to see if there is even a chance that the request can be satisifed.
  c) invoke utility method that creates a FHIR Bundle as the response.
4. The plan would be to abstract steps 3b,3c from the current GET method into a private (internal) method that performs the bulk of the processing logic and returns the FHIR Bundle. The GET method retains step 3a.
5. New code encapsulating an HTTP POST will be developed for both STU3 and R4 _patient search_. Bascially it will be a close duplicate and functionally equivalent of step 3a, with the difference constrained to how the service parameters are reaped.
6. The plan for the new POST request is to mimic the current GET request, which supports a hashed MBI and/or HICN parameter; however, in checking with peering partners, none currently use HICN in any manner when interacting with BFD. So this may present an opportunity to remove code cruft associated with HICN-level lookups.
7. In order to preserve current logging visibility of service requests, in particular the visiblity to the parameters of a POST request, a Jetty logging interceptor will be developed that logs the request and its parameters in such a way as to obfuscate any PII data. Since the _patient search_ request is not heavily used, the obfuscation of an MBI may occur in the interceptor by encrypting the MBI parameter using a similar algorithm (with some changes) currently in place.
8. In addition to actual service code changes, the LOE will need to accomodate unit, end-to-end, and integration testing. In additition, all documentation artifacts should be checked for and changes made as needed.
9. The immediate aftermath of a deployment will probably manifest itself as:
- peering partners will continue to use the HTTP GET _patient search_.
- BFD will publish an end-of-life plan for removing support for the HTTP GET; this gives peering partners a clear timeframe for when they need to implement their changes to use the new HTTP POST.

### Proposed Solution: Unresolved Questions
[Proposed Solution: Unresolved Questions]: #proposed-solution-unresolved-questions

1. Can we remove support for HICN lookups since no peering
partners currently use HICN and have not done so for some time. **AND** 
2. Is there a better way to log sensitive (PII,PHI) information?
3. The PACA component within BFD currently depends on hashed MBI_NUM for some of its services; can a _one-size fits all_ strategy of HTTP POST operated for all aspects of BFD.

### Proposed Solution: Drawbacks
[Proposed Solution: Drawbacks]: #proposed-solution-drawbacks

There are some drawbacks for the proposed solution, espeically in light of how some peering partners have a preconcieved notion (based on current usage) that implementing _patient search_ as an HTTP POST goes against the FHIR spec....**It does not!**
- Adoption should not require extensive engineering work by either BFD or peering partners; any work required of peering partners represents some risk to adoption. This is mitigated by initial support for both GET and POST, but at some point BFD will want to remove support for GET, which creates a deadline for clients to change their implementation.
- BFD will need to resolve how logging of POST requests will be handled.
- While not really a drawback, much code cruft could be addressed (cleaned up) with removal of hashed MBI, HICN.

## Prior Art
[Prior Art]: #prior-art
While BFD has no prior work replacing HTTP GET with HTTP POST, the FHIR specification is clear on how this could be implemented. 
## Addenda
[Addendums]: #addendums
The following addenda are recommended reading before voting on this proposal:
* [FHIR Patient Search](https://hl7.org/fhir/STU3/search.html#2.21.1.2) 

