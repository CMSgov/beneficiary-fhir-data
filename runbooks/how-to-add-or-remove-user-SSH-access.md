# How to Add or Remove Users' SSH Access

- [How to Add or Remove Users' SSH Access](#how-to-add-or-remove-users-ssh-access)
  - [Prerequisites](#prerequisites)
  - [Instructions](#instructions)
    - [How to Add a New User's SSH Key and Configure Access](#how-to-add-a-new-users-ssh-key-and-configure-access)

<!-- ## Glossary -->

<!-- ## FAQ -->

## Prerequisites

- Access to the BFD AWS Account
- IAM permissions to decrypt sensitive SSM parameters
- An installation of the AWS CLI that is configured properly for access to the BFD/CMS AWS account
- An installation of the `ansible` CLI
- An installation of the `terraform` CLI
  - Using a tool like `tfenv` allows for multiple installations of Terraform and automatic version
    management
- Your `EDITOR` environment variable set to a proper editor
  - You can set this variable in your `.bashrc` (if you're using `bash`) or `.zshrc` (if you're
    using `zsh`) like so: `export EDITOR=<your editor executable here>`. Other shells may have a
    different syntax for setting environment variables or a different configuration file
- This repository, `beneficiary-fhir-data`, pulled down locally

## Instructions

### How to Add a New User's SSH Key and Configure Access

> It is recommended that you read the following `README`s for more information on the SSM
> configuration scheme used by BFD before continuing:
>
> - [`mgmt`'s `base_config` `README`](../ops/terraform/env/mgmt/base_config/README.md)
> - [`base` service `README`](../ops/terraform/services/base/README.md)
>
> Additionally:
>
> - You will need to know the user's EUA
> - You will need the user's SSH public key and desired username
> - You will need to know the level of access the user has to each established environment and
>   whether they should be given access by default

1. In your terminal, navigate to the root of your local copy of the `beneficiary-fhir-data`
   repository using `cd`
2. In your terminal, relative to the root of this repository, `cd` to the directory associated with
   the `mgmt` Terraform module:

   ```bash
   cd ops/terraform/env/mgmt
   ```

3. Initialize the Terraform state locally:

   ```bash
   terraform init
   ```

4. Once initialized, view the Terraform plan and verify that Terraform is able to load state for all
   of the resources managed by the `mgmt` module and that no changes are necessary:

   ```bash
   terraform plan
   ```

5. Navigate into the `base_config` module's directory:

   ```bash
   cd base_config
   ```

6. Ensure you are authenticated with AWS and are able to run AWS CLI commands
7. Open the encrypted yaml `mgmt.eyaml` for editing using the `edit-eyaml.sh` script using the
   commands below. This will decrypt the encrypted `mgmt.eyaml` file and open it in your defined
   `EDITOR`. The script will wait until the file is _closed_ by your editor, at which point it will
   re-encrypt `mgmt.eyaml` with your changes and save it

   ```bash
   chmod +x scripts/edit-eyaml.sh
   scripts/edit-eyaml.sh mgmt
   ```

8. You will see many keys grouped together in the format shown below. In the example below, `....`
   represents each user's EUA ID. Each key represents the following:

   1. `ssh_user` represents the user's SSH username that they will use to connect to a machine using
      their key
   2. `ssh_public_key` represents the _public_ key component of the user's key-pair. This must be
      generated by the user themselves and provided to you
   3. `ssh_default_access` defines whether the user has access, _by default_, to connect via SSH to
      any BFD instance in _any_ environment. Essentially, this overrides per-environment access for
      a given user and should be set to `true` for users that require access in all environments
      (such as those in our on-call rotation)
   4. `ssh_default_sudoer` defines whether the user has `sudoer` permission, _by defualt_, for any
      BFD instance in _any_ environment. Essentially, this overrides per-environment `sudoer` access
      for a given user and should only be set to `true` for users that need access to `sudo` in all
      environments (such as those in our on-call rotation)

   ```yml
   /bfd/mgmt/common/sensitive/user/..../ssh_user: "some.username"
   /bfd/mgmt/common/sensitive/user/..../ssh_public_key: "ssh-key .... identity"
   /bfd/mgmt/common/sensitive/user/..../ssh_default_access: bool
   /bfd/mgmt/common/sensitive/user/..../ssh_default_sudoer: bool
   ```

9. Following the format outlined in step #8, append the new user's `ssh_user`, `ssh_public_key`,
   `ssh_default_access`, and `ssh_default_sudoer` values (depending on their required level of
   access) to the end of the block associated with SSH. Remember, you will need the user's EUA as it
   is part of the SSM parameter's path
10. Close the file. This should immediately update the encrypted `mgmt.eyaml` with your new changes
11. Return to the `mgmt` module:

    ```bash
    cd ..
    ```

12. Plan the changes to the Terraform state and verify that there are only _additions_ to the state
    and that these additions correspond to the new SSH SSM parameters defined in step #9:

    ```bash
    terraform plan
    ```

13. Assuming that there are no anomalous changes and that the plan matches expectations, apply the
    plan:

    ```bash
    terraform apply
    ```

14. Now that the user's username and SSH public key are available in the `mgmt` environment, the
    user's SSH access and `sudoer` access can be defined per-environment. If the user has been given
    default access to SSH _and_ to use `sudo` then steps #15 through #24 can be skipped as the user
    does not need to be configured in our established environments
15. **From the root of the repository**, navigate to the `base` Terraform service module:

    ```bash
    cd ops/terraform/services/base
    ```

16. Once again, initialize the module:

    ```bash
    terraform init
    ```

17. Then, select the workspace corresponding to the environment you are provisioning the user's
    access for:

    ```bash
    terraform workspace select <prod|prod-sbx|test>
    ```

18. Then, run the plan and verify that all of `base`'s resources are found and that there are no
    changes:

    ```bash
    terraform plan
    ```

19. Similarly to step #7, use the `edit-eyaml.sh` to open the corresponding environment's `.eyaml`
    in your defined `EDITOR`:

    ```bash
    chmod +x scripts/edit-eyaml.sh
    scripts/edit-eyaml.sh <prod|prod-sbx|test>
    ```

20. Find the block of SSM keys corresponding to SSH, or, if the block of keys do not yet exist,
    append the below to the end of the file. `....` should be replaced with the user's EUA ID. What
    each key represents is as follows:

    1. `ssh_access` defines whether the user has the ability to SSH into instances launched in the
       current environment. If this is `false`, the user will not have the ability to SSH into any
       instance, whereas if this is `true` the user _will_ be able to SSH. Note that this is
       overriden by `ssh_default_access` (in the `mgmt` "environment") if `ssh_default_access` is
       `true`. Omission is treated as `false`
    2. `ssh_sudoer` defines whether the user has the ability to run `sudo` and act as `root` on
       instances launched in the current environment. If this is `false`, the user will not have the
       ability to run `sudo` and act as `root`, whereas if this is `true` the user _will_ be able to
       do so. Note that this is overriden by `ssh_default_sudoer` (in the `mgmt` "environment") if
       `ssh_default_sudoer` is `true`. Omission is treated as `false`

    ```yaml
    /bfd/${env}/common/sensitive/user/..../ssh_access: bool
    /bfd/${env}/common/sensitive/user/..../ssh_sudoer: bool
    ```

21. Close the file. This will save your changes and re-encrypt the encrypted YAML file for the
    current environment.
22. Plan the changes to the Terraform state and verify that there are only _additions_ to the state
    and that these additions correspond to the new SSH SSM parameters defined in step #20:

    ```bash
    terraform plan
    ```

23. Assuming that there are no anomalous changes and that the plan matches expectations, apply the
    plan:

    ```bash
    terraform apply
    ```

24. Repeat steps #17 through #23 for each environment that the user should be provisioned in
25. Once finished, the new user will be _fully_ provisioned the next time the `Build App AMIs` stage
    is ran in our deployment pipeline. In the meantime, anytime a _brand new_ instance is _launched_
    the new user will be able to SSH into it assuming either `ssh_default_access` is `true` or if,
    for the instance's environment, `ssh_access` is `true`
