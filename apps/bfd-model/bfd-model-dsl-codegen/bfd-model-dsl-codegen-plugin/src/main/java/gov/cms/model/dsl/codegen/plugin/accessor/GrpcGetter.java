package gov.cms.model.dsl.codegen.plugin.accessor;

import static gov.cms.model.dsl.codegen.plugin.transformer.TransformerUtil.createPropertyAccessCodeBlock;

import com.squareup.javapoet.CodeBlock;
import gov.cms.model.dsl.codegen.plugin.model.TransformationBean;
import gov.cms.model.dsl.codegen.plugin.transformer.FieldTransformer;

/**
 * {@link Getter} implementation that requires the source object to be a protoc generated stub
 * object for a GRPC message. The generated code follows the conventions of the protoc generated
 * code for hasX methods (determine if an optional field has a value) and getX methods (get the
 * value of a field).
 */
public class GrpcGetter implements Getter {
  /** Sharable singleton instance. */
  public static final Getter Instance = new GrpcGetter();

  /**
   * {@inheritDoc}
   *
   * <p>This implementation requires that the source object was generated by the protoc compiler and
   * follows appropriate conventions.
   */
  public CodeBlock createHasRef(TransformationBean transformation) {
    return createPropertyAccessCodeBlock(
        transformation,
        fieldName -> CodeBlock.of("$L::has$L", FieldTransformer.SOURCE_VAR, fieldName),
        (fieldName, propertyName) ->
            CodeBlock.of(
                "() -> $L.has$L() && $L.get$L().has$L()",
                FieldTransformer.SOURCE_VAR,
                fieldName,
                FieldTransformer.SOURCE_VAR,
                fieldName,
                propertyName));
  }

  /**
   * {@inheritDoc}
   *
   * <p>This implementation requires that the source object was generated by the protoc compiler and
   * follows appropriate conventions.
   */
  public CodeBlock createHasCall(TransformationBean transformation) {
    return createPropertyAccessCodeBlock(
        transformation,
        fieldName -> CodeBlock.of("$L.has$L()", FieldTransformer.SOURCE_VAR, fieldName),
        (fieldName, propertyName) ->
            CodeBlock.of(
                "($L.has$L() && $L.get$L().has$L())",
                FieldTransformer.SOURCE_VAR,
                fieldName,
                FieldTransformer.SOURCE_VAR,
                fieldName,
                propertyName));
  }

  /**
   * {@inheritDoc}
   *
   * <p>This implementation requires that the source object was generated by the protoc compiler and
   * follows appropriate conventions.
   */
  public CodeBlock createGetRef(TransformationBean transformation) {
    return createPropertyAccessCodeBlock(
        transformation,
        fieldName -> CodeBlock.of("$L::get$L", FieldTransformer.SOURCE_VAR, fieldName),
        (fieldName, propertyName) ->
            CodeBlock.of(
                "() -> $L.get$L().get$L()", FieldTransformer.SOURCE_VAR, fieldName, propertyName));
  }

  /**
   * {@inheritDoc}
   *
   * <p>This implementation requires that the source object was generated by the protoc compiler and
   * follows appropriate conventions.
   */
  public CodeBlock createGetCall(TransformationBean transformation) {
    return createPropertyAccessCodeBlock(
        transformation,
        fieldName -> CodeBlock.of("$L.get$L()", FieldTransformer.SOURCE_VAR, fieldName),
        (fieldName, propertyName) ->
            CodeBlock.of(
                "$L.get$L().get$L()", FieldTransformer.SOURCE_VAR, fieldName, propertyName));
  }
}
