package gov.cms.bfd.sharedutils.database;

import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.sql.DataSource;
import lombok.Builder;
import lombok.Value;
import lombok.experimental.Accessors;
import software.amazon.jdbc.ConnectionPluginFactory;
import software.amazon.jdbc.dialect.Dialect;
import software.amazon.jdbc.ds.AwsWrapperDataSource;
import software.amazon.jdbc.hostlistprovider.RdsHostListProvider;
import software.amazon.jdbc.plugin.AuroraConnectionTrackerPluginFactory;
import software.amazon.jdbc.plugin.AuroraInitialConnectionStrategyPluginFactory;
import software.amazon.jdbc.plugin.AwsSecretsManagerConnectionPluginFactory;
import software.amazon.jdbc.plugin.ConnectTimeConnectionPluginFactory;
import software.amazon.jdbc.plugin.DataCacheConnectionPluginFactory;
import software.amazon.jdbc.plugin.DriverMetaDataConnectionPluginFactory;
import software.amazon.jdbc.plugin.ExecutionTimeConnectionPluginFactory;
import software.amazon.jdbc.plugin.LogQueryConnectionPluginFactory;
import software.amazon.jdbc.plugin.dev.DeveloperConnectionPluginFactory;
import software.amazon.jdbc.plugin.efm.HostMonitoringConnectionPluginFactory;
import software.amazon.jdbc.plugin.failover.FailoverConnectionPluginFactory;
import software.amazon.jdbc.plugin.federatedauth.FederatedAuthPluginFactory;
import software.amazon.jdbc.plugin.federatedauth.OktaAuthPluginFactory;
import software.amazon.jdbc.plugin.iam.IamAuthConnectionPluginFactory;
import software.amazon.jdbc.plugin.readwritesplitting.ReadWriteSplittingPluginFactory;
import software.amazon.jdbc.plugin.staledns.AuroraStaleDnsPluginFactory;
import software.amazon.jdbc.plugin.strategy.fastestresponse.FastestResponseStrategyPluginFactory;

/** The user-configurable options that specify how to access the application's database. */
@Value
public class DatabaseOptions {
  /** Regex that matches proper JDBC URLs and extracts groups containing their host and port. */
  private static final Pattern URL_PATTERN =
      Pattern.compile("^jdbc:[a-z]+://([^:/]+)(:([0-9]+))?/", Pattern.CASE_INSENSITIVE);

  /** Group number for host matched by {@link #URL_PATTERN}. */
  private static final int URL_HOST_GROUP = 1;

  /** Group number for port matched by {@link #URL_PATTERN}. */
  private static final int URL_PORT_GROUP = 3;

  /** Used to define how to authenticate with the database. */
  public enum AuthenticationType {
    /** Authenticate using plain JDBC authentication with a provided password. * */
    JDBC,
    /** Authentication using an RDS generated token in place of a provided password. * */
    RDS
  }

  /**
   * Used to define which type of {@link DataSource} is used by the application to connect to the
   * database.
   */
  public enum DataSourceType {
    /** Specifies that a {@link HikariDataSource} should be used. */
    HIKARI,
    /** Specifies that a {@link AwsWrapperDataSource} should be used. */
    AWS_WRAPPER
  }

  /** How to authenticate with the database. */
  AuthenticationType authenticationType;

  /** Which type of {@link DataSource} to use. */
  DataSourceType dataSourceType;

  /** The JDBC URL of the database. */
  String databaseUrl;

  /** The username for the database. */
  String databaseUsername;

  /** The password for the database. */
  String databasePassword;

  /**
   * Options configuring either an "external" {@link HikariDataSource} or the internal Hikari
   * connection pool of the {@link AwsWrapperDataSource}.
   */
  HikariOptions hikariOptions;

  /**
   * Options configuring the {@link AwsWrapperDataSource}, if specified by {@link #dataSourceType}.
   * Nullable, as these options can be omitted in the case where {@link #dataSourceType} is {@link
   * DataSourceType#HIKARI}.
   */
  @Nullable AwsJdbcWrapperOptions awsJdbcWrapperOptions;

  /**
   * Initializes an instance. The builder class generated by lombok calls this constructor.
   *
   * @param authenticationType optional value to use for {@link #authenticationType}. Defaults to
   *     {@link AuthenticationType#JDBC}
   * @param dataSourceType optional value to use for {@link #dataSourceType}. Defaults to {@link
   *     DataSourceType#HIKARI}
   * @param databaseUrl the value to use for {@link #databaseUrl}
   * @param databaseUsername the value to use for {@link #databaseUsername}
   * @param databasePassword "optional" (if {@link #authenticationType} is {@link
   *     AuthenticationType#RDS}) value to use for {@link #databasePassword}
   * @param hikariOptions optional value to use for {@link #hikariOptions}. If unspecified, a
   *     default {@link HikariOptions} is generated
   * @param awsJdbcWrapperOptions optional value to use for {@link #awsJdbcWrapperOptions}
   */
  @Builder(toBuilder = true)
  private DatabaseOptions(
      @Nullable AuthenticationType authenticationType,
      @Nullable DataSourceType dataSourceType,
      String databaseUrl,
      String databaseUsername,
      @Nullable String databasePassword,
      @Nullable HikariOptions hikariOptions,
      @Nullable AwsJdbcWrapperOptions awsJdbcWrapperOptions) {
    Preconditions.checkArgument(
        !Strings.isNullOrEmpty(databaseUrl), "databaseUrl must be non-empty");
    Preconditions.checkNotNull(databaseUsername, "databaseUsername must not be null");
    Preconditions.checkArgument(
        authenticationType == AuthenticationType.RDS || databasePassword != null);
    Preconditions.checkArgument(
        dataSourceType != DataSourceType.AWS_WRAPPER || awsJdbcWrapperOptions != null,
        "AWS JDBC Wrapper options must be specified if the dataSourceType is specified as AWS_WRAPPER");
    this.dataSourceType = dataSourceType != null ? dataSourceType : DataSourceType.HIKARI;
    this.authenticationType =
        authenticationType != null ? authenticationType : AuthenticationType.JDBC;
    this.databaseUrl = databaseUrl;
    this.databaseUsername = databaseUsername;
    this.databasePassword = databasePassword;
    this.hikariOptions = hikariOptions != null ? hikariOptions : HikariOptions.builder().build();
    this.awsJdbcWrapperOptions = awsJdbcWrapperOptions;
  }

  /**
   * Parses the database host from the {@link #databaseUrl}. Used with RDS authentication.
   *
   * @return host or empty if parsing fails
   */
  public Optional<String> getDatabaseHost() {
    return parseUrl(URL_HOST_GROUP);
  }

  /**
   * Parses the database port from the {@link #databaseUrl}. Used with RDS authentication.
   *
   * @return port or empty if parsing fails
   */
  public Optional<Integer> getDatabasePort() {
    return parseUrl(URL_PORT_GROUP).map(Integer::parseInt);
  }

  /**
   * Parses {@link #databaseUrl} to obtain a match group.
   *
   * @param groupNumber number of the match group to return
   * @return matched group value from the URL (if any)
   */
  private Optional<String> parseUrl(int groupNumber) {
    final Matcher matcher = URL_PATTERN.matcher(databaseUrl);
    if (matcher.find() && matcher.groupCount() >= groupNumber) {
      return Optional.of(matcher.group(groupNumber));
    } else {
      return Optional.empty();
    }
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("DatabaseOptions [databaseUrl=");
    builder.append(databaseUrl);
    builder.append(", databaseUsername=");
    builder.append("***");
    builder.append(", databasePassword=");
    builder.append("***");
    builder.append(", hikariOptions=");
    builder.append(hikariOptions);
    if (awsJdbcWrapperOptions != null) {
      builder.append(", awsJdbcWrapperOptions=");
      builder.append(awsJdbcWrapperOptions);
    }
    builder.append("]");
    return builder.toString();
  }

  /**
   * User-configurable options for a subset of relevant HikariCP configuration consumed by all
   * supported {@link DataSource} types. Omitting any value from the generated builder will result
   * in a default value matching the defaults provided by HikariCP.
   */
  @Builder
  @Value
  public static class HikariOptions {
    /**
     * Maximum size of the connection pool. Corresponds to {@link HikariConfig#maxPoolSize}.
     * Defaults to the number of processors available to the JVM.
     */
    @Builder.Default int maximumPoolSize = Runtime.getRuntime().availableProcessors();

    /**
     * Minimum number of idle connections to always maintain in the pool. Corresponds to {@link
     * HikariConfig#minIdle}. Defaults to the number of processors available to the JVM.
     */
    @Builder.Default int minimumIdleConnections = Runtime.getRuntime().availableProcessors();

    /**
     * Maximum amount of time a connection is allowed to sit idle in the pool. Corresponds to {@link
     * HikariConfig#idleTimeout}. Defaults to 10 minutes.
     */
    @Builder.Default long idleTimeoutMs = TimeUnit.MINUTES.toMillis(10);

    /**
     * Determines how the connection pool handles initial connection failures. A positive number
     * specifies the timeout for attempting to acquire an initial connection; if unsuccessful within
     * this period, an exception is thrown. Only applies after the "connection timeout" ({@link
     * #connectionTimeoutMs}) Corresponds to {@link HikariConfig#initializationFailTimeout}.
     * Defaults to 1 millisecond.
     */
    @Builder.Default long initializationFailTimeoutMs = 1;

    /**
     * Maximum amount of time the application will wait for a connection from the pool. Corresponds
     * to {@link HikariConfig#connectionTimeout}. Defaults to 30 seconds.
     */
    @Builder.Default long connectionTimeoutMs = TimeUnit.SECONDS.toMillis(30);

    /**
     * How frequently HikariCP will attempt to keep a connection alive in order to prevent it from
     * being timed out. Must be less than the "max lifetime" ({@link #maxConnectionLifetimeMs}).
     * Corresponds to {@link HikariConfig#keepaliveTime}. Defaults to 0.
     */
    @Builder.Default long keepaliveTimeMs = 0;

    /**
     * Controls the maximum amount of time a connection will be tested for aliveness. Must be less
     * than the "connection timeout" {@link #connectionTimeoutMs}. Corresponds to {@link
     * HikariConfig#validationTimeout}. Defaults to 5 seconds.
     */
    @Builder.Default long validationTimeoutMs = TimeUnit.SECONDS.toMillis(5);

    /**
     * Maximum lifetime of a connection in the pool. Corresponds to {@link
     * HikariConfig#maxLifetime}. Defaults to 30 minutes.
     */
    @Builder.Default long maxConnectionLifetimeMs = TimeUnit.MINUTES.toMillis(30);
  }

  /**
   * User-configurable options for a subset of relevant AWS JDBC Wrapper configuration consumed by
   * the {@link AwsWrapperDataSource}.
   */
  @Value
  public static class AwsJdbcWrapperOptions {
    /**
     * Static map of JDBC wrapper plugins names to their respective factories. Used to configure the
     * custom preset. Taken directly from {@link software.amazon.jdbc.ConnectionPluginChainBuilder}.
     */
    private static final Map<String, Class<? extends ConnectionPluginFactory>>
        pluginFactoriesByCode =
            new HashMap<>() {
              {
                put("executionTime", ExecutionTimeConnectionPluginFactory.class);
                put("logQuery", LogQueryConnectionPluginFactory.class);
                put("dataCache", DataCacheConnectionPluginFactory.class);
                put("efm", HostMonitoringConnectionPluginFactory.class);
                put(
                    "efm2",
                    software.amazon.jdbc.plugin.efm2.HostMonitoringConnectionPluginFactory.class);
                put("failover", FailoverConnectionPluginFactory.class);
                put(
                    "failover2",
                    software.amazon.jdbc.plugin.failover2.FailoverConnectionPluginFactory.class);
                put("iam", IamAuthConnectionPluginFactory.class);
                put("awsSecretsManager", AwsSecretsManagerConnectionPluginFactory.class);
                put("federatedAuth", FederatedAuthPluginFactory.class);
                put("okta", OktaAuthPluginFactory.class);
                put("auroraStaleDns", AuroraStaleDnsPluginFactory.class);
                put("readWriteSplitting", ReadWriteSplittingPluginFactory.class);
                put("auroraConnectionTracker", AuroraConnectionTrackerPluginFactory.class);
                put("driverMetaData", DriverMetaDataConnectionPluginFactory.class);
                put("connectTime", ConnectTimeConnectionPluginFactory.class);
                put("dev", DeveloperConnectionPluginFactory.class);
                put("fastestResponseStrategy", FastestResponseStrategyPluginFactory.class);
                put("initialConnection", AuroraInitialConnectionStrategyPluginFactory.class);
                put("singleNodeHostOverride", SingleNodeHostOverrideConnectionPluginFactory.class);
              }
            };

    /**
     * Whether a custom preset should be generated based upon the given {@link #basePresetCode} and
     * configuration values from this class and {@link HikariOptions}. If {@literal false}, the
     * preset specified by {@link #basePresetCode} will be used, and all configuration (including
     * {@link HikariOptions}) besides {@link #hostSelectorStrategy} will be ignored in favor of the
     * defaults provided by the specified preset.
     */
    @Accessors(fluent = true)
    boolean useCustomPreset;

    /**
     * The AWS JDBC Wrapper configuration preset to either base a custom preset off of, if {@link
     * #useCustomPreset} is {@literal true}, or the preset to use it its entirety.
     */
    String basePresetCode;

    /** List of "plugin factories" that specify the plugins used by the AWS JDBC Wrapper. */
    ImmutableList<Class<? extends ConnectionPluginFactory>> plugins;

    /**
     * The strategy determining how the host selection mechanisms of the {@link
     * AwsWrapperDataSource} will choose which node to initially connect to and which to failover
     * to.
     */
    String hostSelectorStrategy;

    /**
     * The rate, in milliseconds, at which the {@link RdsHostListProvider} will execute the current
     * {@link Dialect}'s topology query (if applicable) to determine the list of available hosts to
     * connect to.
     */
    long clusterTopologyRefreshRateMs;

    /**
     * The rate, in milliseconds, at which the {@link StateAwareMonitoringRdsHostListProvider} will
     * monitor the state of RDS instances in the current cluster as reported by the RDS API.
     */
    long instanceStateMonitorRefreshRateMs;

    /**
     * Initializes an instance. The builder class generated by lombok calls this constructor.
     *
     * @param useCustomPreset the value to use for {@link #useCustomPreset}
     * @param basePresetCode optional value to use for {@link #basePresetCode}. If unspecified the
     *     "E" preset is chosen
     * @param pluginsCsv comma-separated list of plugin codes that will be used to populate {@link
     *     #plugins}. Invalid plugin codes will be discarded. If unspecified no plugins will be
     *     loaded
     * @param hostSelectorStrategy the value to use for {@link #hostSelectorStrategy}. If
     *     unspecified the "roundRobin" strategy is chosen
     * @param clusterTopologyRefreshRateMs the value to use for {@link
     *     #clusterTopologyRefreshRateMs}. If unspecified the default of 30000 (30 seconds) is
     *     chosen
     * @param instanceStateMonitorRefreshRateMs the value to use for {@link
     *     #instanceStateMonitorRefreshRateMs}. If unspecified the default of 5000 (5 seconds) is
     *     chosen
     */
    @Builder()
    private AwsJdbcWrapperOptions(
        boolean useCustomPreset,
        @Nullable String basePresetCode,
        @Nullable String pluginsCsv,
        @Nullable String hostSelectorStrategy,
        @Nullable Long clusterTopologyRefreshRateMs,
        @Nullable Long instanceStateMonitorRefreshRateMs) {
      this.useCustomPreset = useCustomPreset;
      this.basePresetCode = basePresetCode != null ? basePresetCode : "E";
      this.plugins =
          pluginsCsv != null
              ? Arrays.stream(pluginsCsv.split(","))
                  .map(pluginName -> pluginFactoriesByCode.getOrDefault(pluginName.trim(), null))
                  .filter(Objects::nonNull)
                  .collect(ImmutableList.toImmutableList())
              : ImmutableList.of();
      this.hostSelectorStrategy =
          hostSelectorStrategy != null ? hostSelectorStrategy : "roundRobin";
      this.clusterTopologyRefreshRateMs =
          clusterTopologyRefreshRateMs != null ? clusterTopologyRefreshRateMs : 30000L;
      this.instanceStateMonitorRefreshRateMs =
          instanceStateMonitorRefreshRateMs != null ? instanceStateMonitorRefreshRateMs : 5000L;
    }
  }
}
