package gov.cms.bfd.pipeline.app;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import gov.cms.bfd.pipeline.sharedutils.PipelineJob;
import gov.cms.bfd.sharedutils.interfaces.ThrowingConsumer;
import java.time.Clock;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.Nullable;
import javax.annotation.concurrent.GuardedBy;
import javax.annotation.concurrent.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
import software.amazon.awssdk.utils.ThreadFactoryBuilder;

/** Class responsible for executing pipeline jobs in a thread pool. */
@Slf4j
@ThreadSafe
public class PipelineManager implements PipelineJobRunner.Tracker {
  /**
   * We track job results so that tests can check them. This sets a limit on the number we keep
   * around. Needs to be large enough for tests but not so large that it uses a lot of heap in
   * production.
   */
  private static final int MAX_COMPLETED_JOBS = 100;
  /** Function used to sleep. Parameterized for use by unit tests. */
  private final ThrowingConsumer<Long, InterruptedException> sleeper;
  /** Used to get timestamps. Parameterized for use by unit tests. */
  private final Clock clock;
  /** All of the jobs we manage. */
  private final ImmutableList<PipelineJob> jobs;
  /** Thread pool with one thread per job. */
  private final ExecutorService threadPool;
  /** Used to wait for all jobs to terminate. */
  private final CountDownLatch latch;
  /** Used to assign job ids in a thread safe manner. */
  private final AtomicLong idGenerator = new AtomicLong(1);
  /** Recent job results for use by tests. */
  private final LinkedList<PipelineJobRunner.JobRunSummary> completedJobs;
  /**
   * True if all jobs are interruptable. When false we can't interrupt the pool for faster
   * shutdowns.
   */
  private final boolean interruptable;
  /**
   * One {@link Future} per job. Can be used to get job result directly. Access limited to
   * synchronized methods.
   */
  private ImmutableList<Future<Void>> runningJobFutures;
  /** True while we're running. False when we're not. Access limited to synchronized methods. */
  @GuardedBy("this")
  private boolean isRunning;
  /**
   * Any exception generated by a job will halt processing and is stored here. Access limited to
   * synchronized methods.
   */
  @GuardedBy("this")
  private Exception error;

  /**
   * Initializes an instance.
   *
   * @param sleeper used by threads to wait for a set period of time
   * @param clock used to determine current time
   * @param jobs the jobs to execute
   */
  public PipelineManager(
      ThrowingConsumer<Long, InterruptedException> sleeper, Clock clock, List<PipelineJob> jobs) {
    this.sleeper = sleeper;
    this.clock = clock;
    this.jobs = ImmutableList.copyOf(jobs);
    threadPool =
        Executors.newCachedThreadPool(
            new ThreadFactoryBuilder()
                .threadNamePrefix(getClass().getSimpleName())
                .daemonThreads(false)
                .build());
    latch = new CountDownLatch(jobs.size());
    completedJobs = new LinkedList<>();
    interruptable = jobs.stream().allMatch(PipelineJob::isInterruptible);
  }

  /**
   * Can be called only once. Used by main thread. Starts all jobs running by adding them to the
   * thread pool.
   */
  public synchronized void start() {
    if (isRunning || runningJobFutures != null) {
      throw new IllegalStateException("start has already been called");
    }
    var futures = ImmutableList.<Future<Void>>builder();
    for (PipelineJob job : jobs) {
      var jobExecutor = new PipelineJobRunner(this, job, sleeper, clock);
      var future = threadPool.submit(jobExecutor);
      futures.add(future);
    }
    runningJobFutures = futures.build();
    isRunning = true;
  }

  /**
   * Can be called multiple times. Triggers a shutdown of the thread pool and interrupts running
   * threads if {@link #interruptable} is true.
   */
  public synchronized void stop() {
    if (isRunning) {
      if (interruptable) {
        var unscheduled = threadPool.shutdownNow();
        assert unscheduled.size() == 0;
      } else {
        log.info("stopping but must wait for uninterruptible jobs to complete on their own");
        threadPool.shutdown();
      }
      isRunning = false;
    }
  }

  /** Callable by main thread to wait for all jobs to finish running. */
  public void awaitCompletion() {
    while (latch.getCount() > 0) {
      try {
        latch.await();
      } catch (InterruptedException ex) {
        log.debug("caught interrupt - still waiting for latch to reach zero");
      }
    }

    // just in case we somehow aren't stopped
    stop();

    // should return immediately since all jobs are done according to the latch
    log.info("waiting for pool to terminate");
    boolean terminated = false;
    while (!terminated) {
      try {
        terminated = threadPool.awaitTermination(30, TimeUnit.SECONDS);
      } catch (InterruptedException ex) {
        log.debug("caught interrupt - still waiting for thread pool to terminate");
      }
    }
  }

  /**
   * Callable by main thread or test to get any exception thrown by a job.
   *
   * @return first exception thrown by a job
   */
  @Nullable
  public synchronized Exception getError() {
    return error;
  }

  @Override
  public synchronized boolean jobsCanRun() {
    return isRunning && error == null;
  }

  @Override
  public long beginningRun(PipelineJob job) {
    final var runId = idGenerator.getAndIncrement();
    log.info("Job run beginning: type={} id={}", job.getType(), runId);
    return runId;
  }

  @Override
  public synchronized void completedRun(PipelineJobRunner.JobRunSummary summary) {
    log.info("job run complete: {}", summary);
    if (completedJobs.size() > MAX_COMPLETED_JOBS) {
      completedJobs.removeFirst();
    }
    completedJobs.addLast(summary);
  }

  @Override
  public void sleeping(PipelineJob job) {
    log.debug("Job sleeping: type={}", job.getType());
  }

  @Override
  public void stoppingDueToInterrupt(PipelineJob job) {
    log.info("Job interrupted: type={}", job.getType());
  }

  @Override
  public synchronized void stoppingDueToException(PipelineJob job, Exception exception) {
    log.error("Job execution failed: type={} exception={}", job.getType(), exception.getMessage());
    if (this.error == null) {
      this.error = exception;
    } else {
      this.error.addSuppressed(exception);
    }
  }

  @Override
  public void stoppingNormally(PipelineJob job) {
    log.debug("Job stopping: " + job.getType());
  }

  @Override
  public void stopped(PipelineJob job) {
    log.info("Job stopped: " + job.getType());
    latch.countDown();
  }

  /**
   * Callable by tests to get our job summaries.
   *
   * @return list of job summaries
   */
  @VisibleForTesting
  synchronized List<PipelineJobRunner.JobRunSummary> getCompletedJobs() {
    return ImmutableList.copyOf(completedJobs);
  }
}
