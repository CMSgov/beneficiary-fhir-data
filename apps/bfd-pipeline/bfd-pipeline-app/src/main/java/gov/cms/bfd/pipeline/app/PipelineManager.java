package gov.cms.bfd.pipeline.app;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableList;
import gov.cms.bfd.pipeline.sharedutils.PipelineJob;
import gov.cms.bfd.pipeline.sharedutils.PipelineJobOutcome;
import gov.cms.bfd.pipeline.sharedutils.PipelineOutcome;
import gov.cms.bfd.sharedutils.interfaces.ThrowingConsumer;
import jakarta.annotation.Nullable;
import java.time.Clock;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.concurrent.GuardedBy;
import javax.annotation.concurrent.ThreadSafe;
import lombok.extern.slf4j.Slf4j;
import software.amazon.awssdk.utils.ThreadFactoryBuilder;

/** Class responsible for executing pipeline jobs in a thread pool. */
@Slf4j
@ThreadSafe
public class PipelineManager implements PipelineJobRunner.Tracker {
  /**
   * We track job results so that tests can check them. This sets a limit on the number we keep
   * around. Needs to be large enough for tests but not so large that it uses a lot of heap in
   * production.
   */
  private static final int MAX_COMPLETED_JOBS = 100;

  /** Function used to sleep. Parameterized for use by unit tests. */
  private final ThrowingConsumer<Long, InterruptedException> sleeper;

  /** Used to get timestamps. Parameterized for use by unit tests. */
  private final Clock clock;

  /** All of the jobs we manage. */
  private final ImmutableList<PipelineJob> jobs;

  /** Thread pool with one thread per job. */
  private final ExecutorService threadPool;

  /** Used to wait for all jobs to terminate. */
  private final CountDownLatch latch;

  /** Used to assign job ids in a thread safe manner. */
  private final AtomicLong idGenerator = new AtomicLong(1);

  /** Recent job results for use by tests. */
  private final LinkedList<PipelineJobRunner.JobRunSummary> completedJobs;

  /** Termination requested. */
  private boolean terminationRequested = false;

  /**
   * True if all jobs are interruptable. When false we can't interrupt the pool for faster
   * shutdowns.
   */
  private final boolean interruptable;

  /**
   * One {@link Future} per job. Can be used to get job result directly. Access limited to
   * synchronized methods.
   */
  @GuardedBy("this")
  private ImmutableList<Future<?>> runningJobFutures;

  /** True while we're running. False when we're not. Access limited to synchronized methods. */
  @GuardedBy("this")
  private boolean isRunning;

  /**
   * Any exception generated by a job will halt processing and is stored here. Access limited to
   * synchronized methods.
   */
  @GuardedBy("this")
  private Exception error;

  /**
   * Initializes an instance. Creates the thread pool but does not schedule any jobs yet.
   *
   * @param sleeper used by threads to wait for a set period of time
   * @param clock used to determine current time
   * @param jobs the jobs to execute
   */
  public PipelineManager(
      ThrowingConsumer<Long, InterruptedException> sleeper, Clock clock, List<PipelineJob> jobs) {
    this.sleeper = sleeper;
    this.clock = clock;
    this.jobs = ImmutableList.copyOf(jobs);
    threadPool =
        Executors.newCachedThreadPool(
            new ThreadFactoryBuilder()
                .threadNamePrefix(getClass().getSimpleName())
                .daemonThreads(false)
                .build());
    latch = new CountDownLatch(jobs.size());
    completedJobs = new LinkedList<>();
    interruptable = jobs.stream().allMatch(PipelineJob::isInterruptible);
  }

  /**
   * Can be called only once. Used by main thread. Starts all jobs running by adding them to the
   * thread pool. Since our pool automatically assigns one thread per job all of them will begin
   * running immediately.
   */
  public synchronized void start() {
    if (isRunning || runningJobFutures != null) {
      throw new IllegalStateException("start has already been called");
    }
    var futures = ImmutableList.<Future<?>>builder();
    for (PipelineJob job : jobs) {
      var jobExecutor = new PipelineJobRunner(this, job, sleeper, clock);
      var future = threadPool.submit(jobExecutor);
      futures.add(future);
    }
    runningJobFutures = futures.build();
    isRunning = true;
  }

  /**
   * Can be called multiple times. Triggers a shutdown of the thread pool and interrupts running
   * threads if {@link #interruptable} is true.
   */
  public synchronized void stop() {
    if (isRunning) {
      if (interruptable) {
        var unscheduled = threadPool.shutdownNow();
        // Just a sanity check.  We only schedule one job per pipeline job and have dedicated
        // threads so there should never be any unscheduled jobs waiting in a queue.
        assert unscheduled.size() == 0;
      } else {
        log.info("stopping but must wait for uninterruptible jobs to complete on their own");
        threadPool.shutdown();
      }
      isRunning = false;
    }
  }

  /**
   * Callable by main thread to wait for all jobs to finish running. This is potentially an infinite
   * loop but that's by design. We call this while the program is running to wait for it to complete
   * and a common scenario is for the pipeline to run forever.
   *
   * <p>External causes like jobs completing on their own or calls to {@link #stop} from the
   * shutdown handler will cause the pool to shut down gracefully while we wait and thus allow us to
   * return.
   *
   * @return outcome.
   */
  public PipelineOutcome awaitCompletion() {
    // Calls to the latch are automatically synchronized on the latch.
    while (latch.getCount() > 0) {
      try {
        latch.await();
      } catch (InterruptedException ex) {
        log.debug("caught interrupt - still waiting for latch to reach zero");
      }
    }

    // just in case we somehow aren't stopped
    stop();

    log.info("waiting for pool to terminate");
    boolean terminated = false;
    while (!terminated) {
      try {
        // Should return immediately since latch indicated that all jobs are done.
        // Calls to the pool are synchronized on the pool itself.
        terminated = threadPool.awaitTermination(30, TimeUnit.SECONDS);
      } catch (InterruptedException ex) {
        log.debug("caught interrupt - still waiting for thread pool to terminate");
      }
    }
    log.info("pool has terminated");

    if (this.terminationRequested) {
      return PipelineOutcome.TERMINATE_INSTANCE;
    } else {
      return PipelineOutcome.STOP_SERVICE;
    }
  }

  /**
   * Callable by main thread or test to get any exception thrown by a job.
   *
   * @return first exception thrown by a job
   */
  @Nullable
  public synchronized Exception getError() {
    return error;
  }

  /**
   * OK to run unless {@link #stop} has been called or an exception has been caught.
   *
   * <p>{@inheritDoc}
   *
   * @return true if OK for job to run
   */
  @Override
  public synchronized boolean jobsCanRun() {
    return isRunning && error == null;
  }

  /**
   * Just logs the event and returns a unique id.
   *
   * <p>{@inheritDoc}
   *
   * @param job the job that is starting
   * @return job id
   */
  @Override
  public long beginningRun(PipelineJob job) {
    final var runId = idGenerator.getAndIncrement();
    log.info("Job run beginning: type={} id={}", job.getType(), runId);
    return runId;
  }

  /**
   * Records the {@link gov.cms.bfd.pipeline.app.PipelineJobRunner.JobRunSummary} in a fixed size
   * list.
   *
   * <p>{@inheritDoc}
   *
   * @param summary summaries the outcome of the run
   */
  @Override
  public synchronized void completedRun(PipelineJobRunner.JobRunSummary summary) {
    log.info("job run complete: {}", summary);
    if (completedJobs.size() > MAX_COMPLETED_JOBS) {
      completedJobs.removeFirst();
    }
    completedJobs.addLast(summary);
  }

  /**
   * Just logs the event.
   *
   * <p>{@inheritDoc}
   *
   * @param job the job that is sleeping
   */
  @Override
  public void sleeping(PipelineJob job) {
    log.debug("Job sleeping: type={}", job.getType());
  }

  /**
   * Just logs the event.
   *
   * <p>{@inheritDoc}
   *
   * @param job the job that is stopping
   */
  @Override
  public void stoppingDueToInterrupt(PipelineJob job) {
    log.info("Job interrupted: type={}", job.getType());
  }

  /**
   * Saves the exception for reporting later. This will also prevent other jobs from running so that
   * the pipeline can shut down gracefully without a call to {@link System#exit}.
   *
   * <p>{@inheritDoc}
   *
   * @param job the job that is stopping
   * @param exception the exception that was thrown
   */
  @Override
  public synchronized void stoppingDueToException(PipelineJob job, Exception exception) {
    log.error("Job execution failed: type={} exception={}", job.getType(), exception.getMessage());
    if (this.error == null) {
      this.error = exception;
    } else {
      this.error.addSuppressed(exception);
    }
  }

  /**
   * Just logs the event.
   *
   * <p>{@inheritDoc}
   *
   * @param job the job that is stopping
   */
  @Override
  public void stoppingNormally(PipelineJob job) {
    log.debug("Job stopping: " + job.getType());
  }

  /**
   * Logs the event and counts down the latch to reflect that job has stopped.
   *
   * @param job the job that has stopped
   */
  @Override
  public void stopped(PipelineJob job, PipelineJobOutcome outcome) {
    log.info("Job stopped: " + job.getType());
    if (outcome == PipelineJobOutcome.SHOULD_TERMINATE) {
      this.terminationRequested = true;
    }
    latch.countDown();
  }

  /**
   * Callable by tests to get our job summaries.
   *
   * @return list of job summaries
   */
  @VisibleForTesting
  synchronized List<PipelineJobRunner.JobRunSummary> getCompletedJobs() {
    return ImmutableList.copyOf(completedJobs);
  }
}
