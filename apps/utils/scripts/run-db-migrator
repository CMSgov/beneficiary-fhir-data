#!/bin/bash
# Runs the latest version of BFD db migrator using build artifacts from your git workspace.
# Requires a directory to copy build artifacts into and use as working directory.
# Run with -h option to see command line options.

set -e

if [[ x$BFD_PATH = x ]] ; then
  echo "Please set BFD_PATH environment variable to root of source tree." 1>&2
  echo "It should be the directory containing the ops and apps subdirectories." 1>&1
  exit 1
fi

if [[ x$BFD_EXEC = x ]] ; then
  echo "Please set BFD_EXEC environment variable to a directory scripts can run in." 1>&2
  echo "It should be outside of $BFD_PATH." 1>&2
  exit 1
fi

##############################################################################
#
# BEGIN Local environment configuration.
#
project_dir=$BFD_PATH/apps

# Directory to store binaries and data files when running.
# Also where the script cd's to before running.
# Should be outside of your git workspace to avoid hassles with git.
exec_dir=$BFD_EXEC/db-migrator

# Directory containing your local maven artifacts cache.
repo_dir=$HOME/.m2/repository

# Maximum heap size to use when running
max_heap=512m

# Location of kubernetes configurations.
kubernetes_root=$BFD_PATH/ops/k8s/helm

if [[ ! -d $project_dir ]] ; then
  echo ERROR: $project_dir does not exist. 1>&2
  echo Please set BFD_PATH to the root of the BFD source tree. 1>&2
  exit 1
fi

if [[ ! -d $BFD_EXEC ]] ; then
  echo ERROR: $BFD_EXEC does not exist. 1>&2
  echo Please create it or set BFD_EXEC to a different path. 1>&2
  exit 1
fi

if [[ ! -d $repo_dir ]] ; then
  echo ERROR: $repo_dir does not exist. 1>&2
  echo Please create it or modify this script with alternative path. 1>&2
  exit 1
fi

# ensure that the migrator specific exec directory exists
mkdir -p $exec_dir

#
# END Local environment configuration.
#
##############################################################################

#
# Generic code using settings begins here.
#

# Default option values.
debug_enabled=false
debug_suspend=n
db_host=localhost
db_port=5432
install=true
image_tag=
image_name=bfd-db-migrator
localstack_ip=localhost
kubernetes=false

usage() {
  script_name=`basename $0`
  cat 1>&2 <<EOF
Runs BFD database migrator.  Use command line options to change behaviors.

$script_name [options]
-d db_host[:db_port]  Name of database host.  Optional :n uses port n.
-i image_tag          Runs the migrator as a containing using the image with given tag.
-k                    Run using kubernetes (using ops/k8s).
-l localstack_ip      Localstack IP address (for bridge networking).
-x                    Do not install latest version before running.
-z                    Enable debugger support but start immediately.
-Z                    Enable debugger support and wait for debugger to connect.
-h                    Prints this help message.

Option defaults:
  -d $db_host:$db_port
EOF
}

while getopts "d:i:kl:xzZh" option ; do
  case $option in
  d) IFS=':' read h p <<<"$OPTARG"
     db_host=${h:=$db_host}
     db_port=${p:=$db_port}
     unset h p
     ;;
  i) image_tag=$OPTARG ; install=false ;;
  k) kubernetes=true ; install=false ; db_host=dev-postgres ;;
  l) localstack_ip=$OPTARG ;;
  x) install=false ;;
  z) debug_enabled=true ;;
  Z) debug_enabled=true ; debug_suspend=y ;;
  h) usage ; exit 0 ;;
  *) usage ; exit 1 ;;
  esac
done
shift $((OPTIND - 1))

# No other command line arguments are permitted.
if [[ $# != 0 ]] ; then
  usage
  exit 1
fi

if [[ x$image_tag != x ]] ; then
  echo "using docker image $image_name:$image_tag"
fi

# Either export an environment variable (if not using SSM for config) or set the appropriate
# parameter in SSM if we are using it.  Used to allow localstack based config to simulate using
# SSM in the cloud.
function setvar() {
  ssm_name="$1"
  value="$2"
  if [[ -z "$AWS_REGION" ]] ; then
    # env var names are ssm paths converted upper case and with / replaced by _.
    env_name=`echo "BFD_${ssm_name}" | tr '/' '_' | tr '[a-z]' '[A-Z]'`
    echo export $env_name
    eval "export ${env_name}=\"${value}\""
  else
    full_ssm_name="${SSM_PARAMETER_PATH}/${ssm_name}"
    echo put-parameter $full_ssm_name
    aws ssm put-parameter --overwrite --endpoint-url http://localhost:4566 --name "${full_ssm_name}" --value "${value}" --no-cli-pager # > /dev/null
  fi
}

# Autodetect if localstack is running based on whether we can connect to its port locally.
# Localstack credentials from https://docs.localstack.cloud/references/credentials/
if lsof -Pi :4566 -sTCP:LISTEN -t >/dev/null ; then
  echo "using localstack"
  export AWS_REGION=us-east-1
  export AWS_ENDPOINT=http://${localstack_ip}:4566
  # bfd environment variables
  export AWS_ACCESS_KEY=000000000042
  export AWS_SECRET_KEY=LSIAQAAAAAAVNCBMPNSG
  # aws cli environment variables
  export AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY
  export AWS_SECRET_ACCESS_KEY=$AWS_SECRET_KEY
  SSM_PARAMETER_PATH=/bfd-db-migrator
  export CONFIG_SETTINGS_JSON=$(cat <<EOF
{
  "ssmHierarchies": [ "$SSM_PARAMETER_PATH" ]
}
EOF
)
  queue_name=migrator-status
  setvar sqs/queue_name $queue_name
  echo "ensuring migrator progress queue exists in SQS"
  aws --endpoint-url=http://localhost:4566 sqs create-queue --queue-name=$queue_name --no-cli-pager
fi

ARGS="-Xms${max_heap} -Xmx${max_heap}"
ARGS="$ARGS -Dorg.jboss.logging.provider=slf4j"

# If debug_enabled is true an IDE can connect its debugger on port 5005 to debug the pipeline.
# If debug_suspend is y the pipeline app will wait for a debugger to connect before doing any work.
if [[ $debug_enabled = "true" ]] ; then
  ARGS="$ARGS -agentlib:jdwp=transport=dt_socket,server=y,suspend=${debug_suspend},address=*:5005"
fi

# The migrator app project will contain our runtime artifacts.
target_name=bfd-db-migrator
lib_dir=$exec_dir/lib

cd $exec_dir

# Don't just assume the version will always be 1.0.0-SNAPSHOT, get it dynamically from mvn instead.
project_version=`cd $project_dir ; mvn help:evaluate -Dexpression=project.version | grep -e '^[^\[]'`

# Install has to be true at least once so that the exec_dir can be populated with runtime artifacts.
# Subsequent runs have the option of skipping the install step for slightly faster turn around.
# Here we just copy the application zip file and extract its contents into the exec_dir for use
# in running the application.
if [[ $install = "true" ]] ; then
  binaries_dir=$repo_dir/gov/cms/bfd/${target_name}/${project_version}
  zip_file=${binaries_dir}/${target_name}-${project_version}.zip

  if [[ ! -r $zip_file ]] ; then
    echo ERROR: missing zip file: $zip_file 1>&2
    echo Build $target_name and try again. 1>&2
    exit 1
  fi

  app_name=`basename $zip_file .zip`
  unzip_dir=$app_name

  if [[ -r $unzip_dir ]] ; then
    echo ERROR: unzip root dir already exists - remove it: $unzip_dir 1>&2
    exit 1
  fi

  unzip $zip_file
  if [[ ! -r $unzip_dir ]] ; then
    echo ERROR: $zip_file did not contain expected root dir: $unzip_dir 1>&2
    exit 1
  fi

  jar_file=${exec_dir}/${app_name}.jar
  [[ -r $jar_file ]] && rm -f $jar_file
  [[ -d $lib_dir ]] && rm -rf $lib_dir
  [[ -r $run_script ]] && rm -f $run_script
  mv $unzip_dir/* $exec_dir
  rmdir $unzip_dir
  if [[ ! -r $jar_file ]] || [[ ! -d $lib_dir ]] ; then
    echo "ERROR: Missing jar file or lib directory.  Was zip file valid? (${zip_file})" 1>&2
    exit 1
  fi
elif [[ x$image_tag = x ]] && [[ x$kubernetes = xfalse ]] ; then
  # Just check to be sure we can run without installing and fail if we can't.
  jar_file=`echo ${exec_dir}/${target_name}-${project_version}.jar`
  if [[ ! -r $jar_file ]] || [[ ! -d $lib_dir ]] ; then
    echo "ERROR: Missing $jar_file or lib directory." 1>&2
    echo "Run again without -x option to install binaries." 1>&2
    exit 1
  fi
fi

# Set up the configuration variables using the setvar function.
export BFD_ENV_NAME=laptop
setvar db/url "jdbc:postgresql://${db_host}:${db_port}/fhirdb"
setvar db/username 'bfd'
setvar db/password 'InsecureLocalDev'

classpath="${jar_file}:${exec_dir}/lib/*"
mainClass="gov.cms.bfd.migrator.app.MigratorApp"
[ -n "${JAVA_HOME}" ] && java=${JAVA_HOME}/bin/java || java=java

if [[ x$kubernetes = xtrue ]] ; then
  cd $kubernetes_root
  if [[ ! -r migrator/Chart.yaml ]] ; then
    echo ERROR: unable to find kubernetes resource files in $kubernetes_root 1>&2
    exit 1
  fi
  if [[ $run_mode = "rif" ]] ; then
    pipeline_type="rif"
  else
    pipeline_type="rda"
  fi
  echo running kubernetes job
  echo Ignore \"release: not found\" message if this is first time running in cluster.
  helm -n dev uninstall migrator migrator || true
  helm -n dev install migrator migrator
elif [[ x$image_tag = x ]] ; then
  export CLASSPATH="$classpath"
  exec $java $ARGS $mainClass
else
  echo running container
  docker \
    run \
    --rm \
    --name $image_name \
    --env AWS_REGION \
    --env AWS_ENDPOINT \
    --env AWS_ACCESS_KEY \
    --env AWS_SECRET_KEY \
    --env CONFIG_SETTINGS_JSON \
    --env BFD_SQS_QUEUE_NAME \
    --env HOME=/home/app \
    -v $HOME/.aws/credentials:/home/app/.aws/credentials:ro \
    $image_name:$image_tag
fi
