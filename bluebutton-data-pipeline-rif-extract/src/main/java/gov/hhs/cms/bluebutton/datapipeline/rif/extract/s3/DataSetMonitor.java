package gov.hhs.cms.bluebutton.datapipeline.rif.extract.s3;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import gov.hhs.cms.bluebutton.datapipeline.rif.model.RifFilesEvent;

/**
 * <p>
 * This ETL pipeline is fed by data pushed from CMS' Chronic Conditions Data
 * (CCW) into Amazon's S3 API. The data in S3 will be structured as follows:
 * </p>
 * <ul>
 * <li>Amazon S3 Bucket: <code>etl-data</code>
 * <ul>
 * <li><code>1997-07-16T19:20:30Z</code>
 * <ul>
 * <li><code>manifest.xml</code></li>
 * <li><code>beneficiaries.rif</code></li>
 * <li><code>bcarrier.rif</code></li>
 * <li><code>pde.rif</code></li>
 * </ul>
 * </li>
 * </ul>
 * </li>
 * </ul>
 * <p>
 * In that structure, there will be one top-level directory in the bucket for
 * each data set that has yet to be completely processed by the ETL pipeline.
 * Its name will be an <a href="https://www.w3.org/TR/NOTE-datetime">ISO 8601
 * date and time</a> expressed in UTC, to a precision of at least seconds. This
 * will represent (roughly) the time that the data set was created. Within each
 * of those directories will be a manifest file and the set of RIF files to be
 * processed.
 * </p>
 * <p>
 * The ETL operates in a loop: periodically checking for the oldest manifest
 * file that can be found, waiting for all of the files listed in it to be
 * available (to avoid race conditions in uploads), and then processing all of
 * those files. At this level of detail, everything occurs synchronously; the
 * ETL pipeline will never process more than one data set at a time. This is
 * necessary to ensure data integrity: if updates to claims are processed out of
 * order, the data will end up in the wrong final state.
 * </p>
 */
public final class DataSetMonitor {
	private static final Logger LOGGER = LoggerFactory.getLogger(DataSetMonitor.class);

	private final String bucketName;
	private final int scanRepeatDelay;
	private final DataSetProcessor dataSetProcessor;

	private ScheduledExecutorService dataSetWatcherService;
	private ScheduledFuture<?> dataSetWatcherFuture;

	/**
	 * Constructs a new {@link DataSetMonitor} instance. Note that this must be used
	 * as a singleton service in the application: only one instance running at a
	 * time is supported.
	 * 
	 * @param bucketName
	 *            the name of the AWS S3 bucket to monitor
	 * @param scanRepeatDelay
	 *            the number of milliseconds to wait after completing one
	 *            poll/process operation and starting another
	 * @param dataSetProcessor
	 *            the {@link DataSetProcessor} responsible for processing each
	 *            of the {@link RifFilesEvent}s that are generated by this
	 *            {@link DataSetMonitor}
	 */
	public DataSetMonitor(String bucketName, int scanRepeatDelay, DataSetProcessor dataSetProcessor) {
		this.bucketName = bucketName;
		this.scanRepeatDelay = scanRepeatDelay;
		this.dataSetProcessor = dataSetProcessor;
	}

	/**
	 * Starts this monitor: it will begin regularly polling for and processing
	 * new data sets on a background thread. This particular method will return
	 * immediately, but that background processing will continue to run
	 * asynchronously until {@link #stop()} is called.
	 */
	public void start() {
		this.dataSetWatcherService = Executors.newSingleThreadScheduledExecutor();
		Runnable dataSetWatcher = new DataSetMonitorWorker(bucketName, dataSetProcessor);

		/*
		 * This kicks off the data set watcher, which will be run periodically
		 * (as configured), until this instance's stop() method is called to
		 * request a graceful shutdown. In turn, it basically acts as the
		 * application's main loop, and will drive all of the application's data
		 * processing, etc. on the ScheduledExecutorService's separate thread.
		 * (To be clear: this method does not block, and should return normally
		 * almost immediately.)
		 */
		this.dataSetWatcherFuture = dataSetWatcherService.scheduleWithFixedDelay(dataSetWatcher, 0, scanRepeatDelay,
				TimeUnit.MILLISECONDS);
	}

	/**
	 * <p>
	 * Stops this monitor: it will wait for the current polling/processing
	 * operation (if any) to complete normally, then stop any future
	 * polling/processing runs from starting. This method will block until any
	 * current operations have completed and future ones have been cancelled.
	 * </p>
	 * <p>
	 * <strong>Note:</strong> This might block for a while! Some data sets have
	 * terrabytes of data, and there is no way to safely stop processing in the
	 * middle of a data set.
	 * </p>
	 */
	public void stop() {
		// If we haven't started yet, this is easy.
		if (dataSetWatcherFuture == null)
			return;

		// Signal the scheduler to stop after the current execution (if any).
		dataSetWatcherFuture.cancel(false);

		// Wait for the current execution (if any) to complete.
		waitForStop();

		// Clean house.
		dataSetWatcherService.shutdown();
		dataSetWatcherService = null;
		dataSetWatcherFuture = null;
	}

	/**
	 * Waits for the data set watcher to complete, presumably after something
	 * has asked it to stop. (If that hasn't happened, and doesn't, this method
	 * will block forever.)
	 */
	private void waitForStop() {
		// If we haven't started yet, this is easy.
		if (dataSetWatcherFuture == null)
			return;

		try {
			/*
			 * Our Future here is tied to a Runnable, so there's nothing for
			 * this `.get()` call to actually return. Instead, per the JavaDoc
			 * for ScheduledExecutorService.scheduleWithFixedDelay(...), this
			 * method will block unless/until something cancels the Future. At
			 * that time, it will wait for any current execution/iteration of
			 * the Runnable to complete normally. Then, it will throw a
			 * CancellationException to signal that things have gracefully
			 * stopped. A bit counter-intuitive, but it works.
			 */
			dataSetWatcherFuture.get();
		} catch (CancellationException e) {
			/*
			 * This is expected to occur when the app is being gracefully shut
			 * down (see the stop() method). It should only happen **after** the
			 * last execution of our Runnable. Accordingly, we'll just log the
			 * event and allow this method to stop blocking and return.
			 */
			LOGGER.info("The data set watcher has been gracefully stopped.");
			return;
		} catch (InterruptedException e) {
			/*
			 * Many Java applications use InterruptedExceptions to signal that a
			 * thread should stop what it's doing ASAP. This app doesn't, so
			 * this is unexpected, and accordingly, we don't know what to do.
			 * Safest bet is to blow up.
			 */
			throw new RuntimeException(e);
		} catch (ExecutionException e) {
			/*
			 * This will only occur if the Runnable (dataSetWatcherFuture)
			 * failed with an unhandled exception. This is unexpected, and
			 * accordingly, we don't know what to do. Safest bet is to blow up.
			 */
			throw new RuntimeException(e);
		}
	}
}
