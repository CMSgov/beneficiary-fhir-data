#!/usr/bin/env groovy

// entrypoint to migrator deployment, requires mapped arguments and an aws authentication closure
// attempts to deploy and monitor and return `true` when the migrator signals a zero exit status
boolean deployMigrator(Map args = [:], authFunction) {
    amiId = args.amiId
    bfdEnv = args.bfdEnv
    heartbeatInterval = args.heartbeatInterval ?: 30
    awsRegion = args.awsRegion ?: 'us-east-1'
    gitBranchName = args.gitBranchName

    // authenticate
    authFunction()

    // set sqsQueueName
    sqsQueueName = "${bfdEnv}-db-migrator"

    // precheck
    if (canMigratorDeploymentProceed(sqsQueueName, awsRegion)) {
        println "Proceeding to Migrator Deployment"
    } else {
        println "Halting Migrator Deployment. Check the SQS Queue ${sqsQueueName}."
        return false
    }

    // plan/apply terraform
    executeTerraform(amiId: amiId,
                     bfdEnv: bfdEnv,
                     gitBranchName: gitBranchName,
                     heartbeatInterval: heartbeatInterval,
                     createMigratorInstance: true)

    // monitor migrator deployment
    finalMigratorStatus = monitorMigrator(
        sqsQueueName: sqsQueueName,
        region: awsRegion,
        heartbeatInterval: heartbeatInterval,
        maxMessages: 10,
        authFunction
    )

    // re-authenticate
    authFunction()

    // set return value for final disposition
    if (finalMigratorStatus == '0') {
        migratorDeployedSuccessfully = true
        // Teardown when there is a healthy exit status
        executeTerraform(amiId: amiId, bfdEnv: bfdEnv, gitBranchName: gitBranchName)
    } else {
        migratorDeployedSuccessfully = false
    }

    purgeQueue(sqsQueueName)

    println "Migrator completed with exit status ${finalMigratorStatus}"
    return migratorDeployedSuccessfully
}

// wraps the aws cli's receive-message subcommand to produce JSON objects
// that represent the deployed migrator's state. Contains the following
// fields mapped to string values: pid, start_time, stop_time, status, code
def receiveMigratorMessages(Map args = [:]) {
    maxMessages = args.maxMessages
    region = args.region
    url = args.url
    visibilityTimeoutSeconds = args.visibilityTimeoutSeconds
    waitTimeSeconds = args.waitTimeSeconds

    withEnv(["url=${url}",
             "region=${region}",
             "maxMessages=${maxMessages}",
             "waitTimeSeconds=${waitTimeSeconds}",
             "visibilityTimeoutSeconds=${visibilityTimeoutSeconds}"]) {
        rawMessages = sh(
            returnStdout: true,
            script: '''
#!/usr/bin/env bash
aws sqs receive-message \
  --region "$region" \
  --queue-url "$url" \
  --max-number-of-messages "$maxMessages" \
  --wait-time-seconds "$waitTimeSeconds" \
  --visibility-timeout "$visibilityTimeoutSeconds" \
  --output json \
  --query Messages |\
jq '.? | map({receipt: .ReceiptHandle, body: .Body | fromjson}) | unique'
'''
        ).trim()
    }
    try {
        jsonMessages = readJSON text: rawMessages
    } catch(err) {
        jsonMessages = readJSON text: '[]'
    }
    return jsonMessages
}

// deletes a message by the given `receipt` which indicates the associated message has been proceesed
String deleteMessage(String receipt, String url, String region = 'us-east-1') {
    result = sh(returnStdout: true, script: "aws sqs delete-message --queue-url ${url} --region ${region} --receipt-handle ${receipt}")
    return result
}

// returns true when if the given `sqsQueueName` exists
boolean sqsQueueExists(String sqsQueueName, String region = 'us-east-1') {
    // For whatever reason, the ternary expression doesn't work here. I still don't understand Groovy.
    exists = sh(returnStatus: true, script: "aws sqs get-queue-url --queue-name ${sqsQueueName} --region ${region} --output text")
    if (exists == 0) {
        return true
    } else {
        return false
    }
}

// returns the url of the given `sqsQueueName`
String getSqsQueueUrl(String sqsQueueName, String region = 'us-east-1') {
    url = sh(returnStdout: true, script: "aws sqs get-queue-url --queue-name ${sqsQueueName} --region ${region} --output text").trim()
    return url
}

// polls the given AWS SQS Queue `sqsQueueName` for migrator messages for
// 20s at the `heartbeatInterval`
String monitorMigrator(Map args = [:], authFunction) {
    sqsQueueName = args.sqsQueueName
    region = args.region
    heartbeatInterval = args.heartbeatInterval
    maxMessages = args.maxMessages

    sqsQueueUrl = getSqsQueueUrl(sqsQueueName)
    while (true) {
        authFunction()
        messages = receiveMigratorMessages(
            url: sqsQueueUrl,
            region: region,
            visibilityTimeoutSeconds: 30,
            waitTimeSeconds: 20,
            maxMessages: maxMessages
        )

        // 1. "handle" (capture status, print, delete) each message
        // 2. if the message body contains a non "0/0" (running) value, return it
        for (msg in messages) {
            migratorStatus = msg.body.status
            printMigratorMessage(msg)
            deleteMessage(msg.receipt, sqsQueueUrl)
            if (migratorStatus != '0/0') {
                return migratorStatus
            }
        }
        sleep(heartbeatInterval)
    }
}

// print formatted migrator messages
void printMigratorMessage(message) {
    body = message.body
    println "Timestamp: ${java.time.LocalDateTime.now().toString()}"

    if (body.stop_time == "n/a") {
        println "Migrator ${body.pid} started at ${body.start_time} is running"
    } else {
        println "Migrator ${body.pid} started at ${body.start_time} is no longer running: '${body.code}' '${body.status}' as of ${body.stop_time}"
    }
}

// purge all messages from the given
def purgeQueue(String sqsQueueName, String region = 'us-east-1') {
    sqsQueueUrl = getSqsQueueUrl(sqsQueueName, region)
    result = sh(returnStdout: true, script: "aws sqs purge-queue --queue-url ${url} --region ${region}")
    return result
}

// checks for indications of a running migrator deployment by looking for unconsumed SQS messages
boolean canMigratorDeploymentProceed(String sqsQueueName, String region) {
    println "Checking Migrator Queue ${sqsQueueName} State..."

    if (sqsQueueExists(sqsQueueName)) {
        sqsQueueUrl = getSqsQueueUrl(sqsQueueName)
        println "Queue ${sqsQueueName} exists. Checking for messages in ${sqsQueueUrl} ..."
        migratorMessages = receiveMigratorMessages(
                url: sqsQueueUrl,
                region: region,
                maxMessages: 10,
                visibilityTimeoutSeconds: 0,
                waitTimeSeconds: 0)
        if (migratorMessages?.isEmpty()) {
            println "Queue ${sqsQueueName} is empty. Migrator deployment can proceed!"
            return true
        } else {
            println "Queue ${sqsQueueName} has messages. Is there an old bfd-db-migrator instance running? Migrator deployment cannot proceed."
            return false
        }
    } else {
        println "Queue ${sqsQueueName} does not exist or is inaccessible. Migrator deployment can proceed!"
        return true
    }
}

// initializes, selects appropriate workspace, plans, and applies terraform
def executeTerraform(Map args = [:]) {
    amiId = args.amiId
    bfdEnv = args.bfdEnv
    gitBranchName = args.gitBranchName
    createMigratorInstance = args.createMigratorInstance ?: false
    heartbeatInterval = args.heartbeatInterval ?: 30

    dir("${workspace}/ops/terraform/services/migrator") {
        // Debug output terraform version
        sh "terraform --version"

        // Initilize terraform
        sh "terraform init -no-color"

        // - Attempt to create the desired workspace
        // - Select the desired workspace
        // NOTE: this is the terraform concept of workspace **NOT** Jenkins
        sh """
terraform workspace new "$bfdEnv" 2> /dev/null || true &&\
terraform workspace select "$bfdEnv" -no-color
"""
        // Gathering terraform plan
        echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
        sh """
terraform plan \
-var='ami_id=${amiId}' \
-var='create_migrator_instance=${createMigratorInstance}' \
-var='git_branch_name=${gitBranchName}' \
-var='migrator_monitor_heartbeat_interval_seconds_override=${heartbeatInterval}' \
-no-color -out=tfplan
"""
        // Apply Terraform plan
        echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
        sh '''
terraform apply \
-no-color -input=false tfplan
'''
        echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
    }
}

return this
