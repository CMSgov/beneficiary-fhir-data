---
- name: "Get global SSM user data"
  shell:
    cmd: |
      aws ssm get-parameters-by-path \
        --with-decryption \
        --path "/bfd/mgmt/common/sensitive/user" \
        --recursive \
        --region us-east-1 \
        --query 'Parameters'
  register: global_user_data

- name: "Parse global SSM user data"
  set_fact:
    global_user_data: "{{ global_user_data.stdout }}"

- name: "Get environment-level SSM user data"
  shell:
    cmd: |
      aws ssm get-parameters-by-path \
        --with-decryption \
        --path "/bfd/{{ env }}/common/sensitive/user" \
        --recursive \
        --region us-east-1 \
        --query 'Parameters'
  register: env_user_data
  when: env is defined
  tags:
    - post-ami

- name: "Parse environment-level SSM user data"
  set_fact:
    env_user_data: "{{ env_user_data.stdout | default([], true) }}"

- name: "Merge global and environment level SSM user data"
  set_fact:
    merged_user_data: "{{ env_user_data + global_user_data }}"

- name: "Parse SSH user data from global and environment SSM parameters"
  shell:
    cmd: |
      # This large jq filter will create an array of objects grouped by the user's EUA containing
      # each user's SSH information
      jq '
          [
              .[]
              | select(.Name | contains("ssh"))
              | (.Name | split("/")[6]) as $iam | . += { "Iam": $iam }
          ]
          | group_by(.Iam)
          | .[]
          | map({(.Name | split("/")[7]): .Value})
          | add
      ' <<< "$MERGED_USER_DATA" |
      # This separate invocation of jq will combine the distinct objects emitted by the previous
      # invocation into a single array of objects
      jq -s
  environment:
    MERGED_USER_DATA: "{{ merged_user_data | to_json }}"
  register: unfiltered_ssh_users

- name: "Parse SSH users to apply"
  set_fact:
    unfiltered_ssh_users: "{{ unfiltered_ssh_users.stdout | from_json }}"

- name: "Filter invalid users or users without access"
  loop: "{{ unfiltered_ssh_users }}"
  when: ssh_user_valid
  vars:
    ssh_user_valid: >
      {{ 
        item.ssh_user is defined and 
        item.ssh_public_key is defined and
        (
          item.ssh_default_access | default('false', true) | bool or 
          item.ssh_access | default('false', true) | bool
        ) 
      }}
    ssh_user_entry: "{{ item }}"
  set_fact:
    ssh_users: "{{ ssh_users | default([]) + [ssh_user_entry] }}"

- name: "Add user"
  user:
    name: "{{ item.ssh_user }}"
    password: "{{ item.ssh_pass | default(omit) }}"
    state: present
  with_items: "{{ ssh_users }}"
  become: true

- name: "Add user public key"
  authorized_key:
    user: "{{ item.ssh_user }}"
    key: "{{ item.ssh_public_key }}"
    state: present
  with_items: "{{ ssh_users }}"
  become: true

- name: "Add user to sudoers file"
  lineinfile:
    path: /etc/sudoers
    state: present
    line: "{{ item.ssh_user }} ALL=(ALL) NOPASSWD: ALL"
    validate: /usr/sbin/visudo -cf %s
  with_items: "{{ ssh_users }}"
  when: >
    item.ssh_default_sudoer | default('false', true) | bool or 
    item.ssh_sudoer | default('false', true) | bool
  become: true
