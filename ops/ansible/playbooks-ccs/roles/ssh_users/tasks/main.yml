---
- name: "Get global SSM user data"
  shell:
    cmd: |
      aws ssm get-parameters-by-path \
        --with-decryption \
        --path "/bfd/mgmt/common/sensitive/user" \
        --recursive \
        --region us-east-1 \
        --query 'Parameters' | jq -c '@text'
  register: global_ssh_users

- name: "Parse global SSM user data"
  set_fact:
    global_ssh_users: "{{ global_ssh_users.stdout }}"

- name: "Get environment-level SSM user data"
  shell:
    cmd: |
      aws ssm get-parameters-by-path \
        --with-decryption \
        --path "/bfd/{{ env }}/common/sensitive/user" \
        --recursive \
        --region us-east-1 \
        --query 'Parameters' | jq -c '@text'
  register: env_ssh_users
  when: env is defined
  tags:
    - post-ami

- name: "Parse environment-level SSM user data"
  set_fact:
    env_ssh_users: '{{ env_ssh_users.stdout | default(''"[]"'', true) }}'

- name: "Parse SSH user data from global and environment SSM parameters"
  shell:
    cmd: |
      # jq, when using the @text escape formatter, will add quotes around the output. Since ansible
      # (jinja) will template that quoted string literally into this script, we need to omit quotes
      # The values of both variables will be unescaped JSON, as bash will unescape the string when
      # parsing the script
      mgmt_user_info={{ global_ssh_users }}
      env_user_info={{ env_ssh_users }}
      # This will merge the JSON arrays from the SSM commands above, allowing subsequent jq
      # invocations to operate on them as if they were a single array
      jq -s 'add' <<<"$env_user_info $mgmt_user_info" |
      # This large jq filter will create an array of objects grouped by the user's EUA containing
      # each user's SSH information
      jq '
          [
              .[]
              | select(.Name | contains("ssh"))
              | (.Name | split("/")[6]) as $iam | . += { "Iam": $iam }
          ]
          | group_by(.Iam)
          | .[]
          | map({(.Name | split("/")[7]): .Value})
          | add
      ' |
      # This separate invocation of jq will combine the distinct objects emitted by the previous
      # invocation into a single array of objects
      jq -s
  register: unfiltered_ssh_users

- name: "Parse SSH users to apply"
  set_fact:
    unfiltered_ssh_users: "{{ unfiltered_ssh_users.stdout | from_json }}"

- name: "Filter invalid users or users without access"
  loop: "{{ unfiltered_ssh_users }}"
  when: ssh_user_valid
  vars:
    ssh_user_valid: >
      {{ 
        item.ssh_user is defined and 
        item.ssh_public_key is defined and
        (
          item.ssh_default_access | default('false', true) | bool or 
          item.ssh_access | default('false', true) | bool
        ) 
      }}
    ssh_user_entry: "{{ item }}"
  set_fact:
    ssh_users: "{{ ssh_users | default([]) + [ssh_user_entry] }}"

- name: "Add user"
  user:
    name: "{{ item.ssh_user }}"
    password: "{{ item.ssh_pass | default(omit) }}"
    state: present
  with_items: "{{ ssh_users }}"
  become: true

- name: "Add user public key"
  authorized_key:
    user: "{{ item.ssh_user }}"
    key: "{{ item.ssh_public_key }}"
    state: present
  with_items: "{{ ssh_users }}"
  become: true

- name: "Add user to sudoers file"
  lineinfile:
    path: /etc/sudoers
    state: present
    line: "{{ item.ssh_user }} ALL=(ALL) NOPASSWD: ALL"
    validate: /usr/sbin/visudo -cf %s
  with_items: "{{ ssh_users }}"
  when: >
    item.ssh_default_sudoer | default('false', true) | bool or 
    item.ssh_sudoer | default('false', true) | bool
  become: true
