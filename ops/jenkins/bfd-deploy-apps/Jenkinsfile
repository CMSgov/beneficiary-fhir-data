#!/usr/bin/env groovy

/**
 * <p>
 * This script will be run by Jenkins when building apps and app AMIs.
 * </p>
 */

// These variables are accessible throughout this file (except inside methods and classes).
def gitBranchName
def migratorScripts
def serverScripts
def trimmedEnv
def lockResource
def awsRegion = 'us-east-1'
def migratorRunbookUrl = "https://github.com/CMSgov/beneficiary-fhir-data/blob/master/runbooks/how-to-recover-from-migrator-failures.md"

pipeline {
    agent {
        kubernetes {
            defaultContainer 'bfd-cbc-build'
            yaml """
apiVersion: v1
kind: Pod
spec:
  serviceAccount: bfd
  containers:
  - name: bfd-cbc-build
    image: 'public.ecr.aws/c2o1d8s9/bfd-cbc-build:jdk17-mvn3-tfenv3-latest'
    command:
    - cat
    tty: true
    imagePullPolicy: Always
    resources:
      requests:
        memory: '16384Mi'
        cpu: '8000m'
      limits:
        memory: '16384Mi'
        cpu: '8000m'
"""
        }
    }

    parameters {
        string(
        name: 'env',
        description: 'The BFD Environment to deploy apps to'
        )

        string(
        name: 'migrator_ami_override',
        description: 'The AMI ID to deploy migrator from'
        )

        string(
        name: 'pipeline_ami_override',
        description: 'The AMI ID to deploy pipeline from'
        )

        string(
        name: 'server_ami_override',
        description: 'The AMI ID to deploy server from'
        )

        booleanParam(
            name: 'force_migrator_deployment', 
            description: 'When true, force the migrator to deploy.', 
            defaultValue: false
        )

        string(
        name: 'server_regression_image_override',
        description: 'Overrides the Docker image tag used when deploying the server-regression lambda',
        defaultValue: null
        )
    }

    stages {
        stage('Prepare') {
            steps {
                script {
                    // Address limitations resulting from CVE-2022-24767
                    sh 'git config --global --add safe.directory "$WORKSPACE"'

                    // Get the current commit id
                    gitCommitId = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()

                    // Get the remote repo url. This assumes we are using git+https not git+ssh.
                    gitRepoUrl = sh(returnStdout: true, script: 'git config --get remote.origin.url').trim().replaceAll(/\.git$/, '')

                    // Load the child Jenkinsfiles.
                    migratorScripts = load('ops/terraform/services/migrator/deploy.groovy')
                    serverScripts = load('ops/terraform/services/server/deploy.groovy')

                    trimmedEnv = params.env.trim()
                    lockResource = trimmedEnv == 'prod-sbx' ? 'env_prod_sbx' : "env_${trimmedEnv}"

                    awsAuth.assumeRole()
                }
            }
        }

        stage('Set Branch Name') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    if (env.BRANCH_NAME.startsWith('PR')) {
                        gitBranchName = env.CHANGE_BRANCH
                    } else {
                        gitBranchName = env.BRANCH_NAME
                    }
                }
            }
        }

        stage('Deploy Base') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    lock(resource: lockResource) {
                        awsAuth.assumeRole()
                        terraform.deployTerraservice(
                                env: trimmedEnv,
                                directory: 'ops/terraform/services/base'
                        )
                    }
                }
            }
        }

        stage('Deploy Migrator') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    def mgiratorAmiOverride = (params.migrator_ami_override?.trim())
                                                    ? params.migrator_ami_override.trim()
                                                    : ""

                    lock(resource: lockResource) {
                        migratorDeploymentSuccessful = migratorScripts.deployMigrator(
                            amiId: mgiratorAmiOverride,
                            bfdEnv: trimmedEnv,
                            heartbeatInterval: 30, // TODO: Consider implementing a backoff functionality in the future
                            awsRegion: awsRegion,
                            forceDeployment: params.force_migrator_deployment
                        )

                        if (migratorDeploymentSuccessful) {
                            println "Proceeding to Stage: 'Deploy Pipeline to ${trimmedEnv.toUpperCase()}'"
                        } else {
                            println "See ${migratorRunbookUrl} for troubleshooting resources."
                            error('Migrator deployment failed')
                        }
                    }
                }
            }
        }

        stage('Deploy Pipeline') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    def pipelineAmiOverride = (params.pipeline_ami_override?.trim())
                                    ? [ami_id_override: params.pipeline_ami_override.trim()]
                                    : []
                    lock(resource: lockResource) {
                        awsAuth.assumeRole()
                        terraform.deployTerraservice(
                        env: trimmedEnv,
                        directory: 'ops/terraform/services/pipeline',
                        tfVars: pipelineAmiOverride
                        )
                    }
                }
            }
        }

        stage('Deploy Server') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    lock(resource: lockResource) {
                        awsAuth.assumeRole()
                        	dir("${workspace}/ops/terraform/env/${trimmedEnv}/stateless") {
                                // Debug output terraform version
                                sh "terraform --version"

                                // Initilize terraform
                                sh "terraform init -no-color"

                                // Gathering terraform plan
                                echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
                                sh "terraform plan \
                                -var='fhir_ami=${params.server_ami_override}' \
                                -var='ssh_key_name=bfd-${trimmedEnv}' \
                                -var='git_branch_name=${gitBranchName}' \
                                -var='git_commit_id=${gitCommitId}' \
                                -no-color -out=tfplan"

                                // Apply Terraform plan
                                echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
                                sh "terraform apply \
                                -no-color -input=false tfplan"
                                echo "Timestamp: ${java.time.LocalDateTime.now().toString()}"
                         }

                        awsAuth.assumeRole()
                        terraform.deployTerraservice(
                                env: trimmedEnv,
                                directory: 'ops/terraform/services/server/server-regression',
                                tfVars: [
                                    docker_image_tag_override: params.server_regression_image_override
                                ]
                        )

                        // Deploy the API requests Insights Lambda
                        awsAuth.assumeRole()
                        terraform.deployTerraservice(
                                env: trimmedEnv,
                                directory: 'ops/terraform/services/server/insights/api-requests'
                            )

                        awsAuth.assumeRole()
                        hasRegressionRunSucceeded = serverScripts.runServerRegression(
                                bfdEnv: trimmedEnv,
                                gitBranchName: gitBranchName
                            )

                        if (hasRegressionRunSucceeded) {
                            println 'Regression suite passed, proceeding to next stage...'
                        } else {
                            try {
                                input 'Regression suite failed, check the CloudWatch logs above for more details. Should deployment proceed?'
                                echo "Regression suite failure in '${trimmedEnv}' has been accepted by operator. Proceeding to next stage..."
                            } catch (err) {
                                error "Operator opted to fail deployment due to regression suite failure in '${trimmedEnv}'"
                            }
                        }
                    }
                }
            }
        }
    }
}
