#!/usr/bin/env groovy

/**
 * <p>
 * This script will be run by Jenkins to aide in destroying ephemeral environments.
 * </p>
 */

@Library("bfd@bfd-2646-support-ephemeral-environment-destruction")

// These variables are accessible throughout this file (except inside methods and classes).
def gitBranchName
def trimmedEnv
def bypassStageApproval
def lockResource

// send notifications to slack, email, etc
def sendNotifications(String environment = '', String buildStatus = '', String stageName = '', String gitCommitId = '', String gitRepoUrl = '') {
    // buildStatus of NULL means success
    if (!buildStatus) {
        buildStatus = 'SUCCESS'
    }

    // build colors
    def colorMap = [:]
    colorMap['STARTED']  = '#0000FF'
    colorMap['SUCCESS']  = '#00FF00'
    colorMap['ABORTED']  = '#6A0DAD'
    colorMap['UNSTABLE'] = '#FFFF00'
    colorMap['FAILED']   = '#FF0000'
    def buildColor = colorMap[buildStatus]
    buildColor = buildColor ?: '#FF0000' // default to red

    def branchUrl = "https://github.com/CMSgov/beneficiary-fhir-data/tree/${env.BRANCH_NAME}"

    def msg = ''
    switch (buildStatus) {
        case 'UNSTABLE':
        case 'SUCCESS':
            msg = 'COMPLETED SUCCESSFULLY: DESTROYED BFD EPHEMERAL ENVIRONMENT'
            break
        case 'FAILED':
        case 'FAILURE':
            msg = "FAILED ON ${stageName.toUpperCase()} STAGE ON BRANCH <${branchUrl}|${env.BRANCH_NAME.toUpperCase()}>"
            break
        case 'STARTED':
            msg = 'HAS STARTED'
            break
        case 'ABORTED':
            msg = 'WAS ABORTED'
            break
        default:
            msg = "${buildStatus.toUpperCase()}"
            break
    }

    // build slack message
    def slackMsg = ''
    if (buildStatus == 'UNSTABLE') {
        slackMsg = "UNSTABLE BFD EPHEMERAL ENVIRONMENT DESTROY <${env.BUILD_URL}|#${env.BUILD_NUMBER}> ON BRANCH <${branchUrl}|${env.BRANCH_NAME.toUpperCase()}> ${msg} \n"
    } else {
        slackMsg = "BFD EPHEMERAL ENVIRONMENT DESTROY <${env.BUILD_URL}|#${env.BUILD_NUMBER}> ON BRANCH <${branchUrl}|${env.BRANCH_NAME.toUpperCase()}> FOR ${environment.toUpperCase()} ENVIRONMENT ${msg} \n"
    }
    slackMsg += "\tJob '${env.JOB_NAME}' \n"

    // send Slack messages
    slackSend(color: buildColor, message: slackMsg)
}

pipeline {
    agent {
        kubernetes {
            defaultContainer 'bfd-cbc-build'
            yaml """
apiVersion: v1
kind: Pod
spec:
  serviceAccount: bfd
  containers:
  - name: bfd-cbc-build
    image: 'public.ecr.aws/c2o1d8s9/bfd-cbc-build:jdk17-mvn3-tfenv3-latest'
    command:
    - cat
    tty: true
    imagePullPolicy: Always
    resources:
      requests:
        memory: '16384Mi'
        cpu: '8000m'
      limits:
        memory: '16384Mi'
        cpu: '8000m'
"""
        }
    }

    parameters {
        string(
                name: 'env',
                description: 'The BFD ephemeral environment to destroy'
        )
        booleanParam(
                name: 'bypass_stage_approval',
                description: 'When true, allow the operator to bypass each stage approval',
                defaultValue: false
        )
    }

    stages {
        stage('Validate parameters') {
            when {
                expression {
                    bypassStageApproval = params.bypass_stage_approval
                    trimmedEnv = params.env.trim().toLowerCase()
                    // Check that the environment is ephemeral and not protected before proceeding
                    return ['madeup', 'test', 'prod-sbx', 'prod'].contains(trimmedEnv)
                }
            }
            steps {
                // Tried to destroy a protected environment; abort the build and skip subsequent stages
                error("Unable to destroy the restricted target environment: '${trimmedEnv}', aborting build")
            }
        }

        stage('Prepare') {
            steps {
                script {
                    // Address limitations resulting from CVE-2022-24767
                    sh 'git config --global --add safe.directory "$WORKSPACE"'

                    // Get the current commit id
                    gitCommitId = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()

                    // Get the remote repo url. This assumes we are using git+https not git+ssh.
                    gitRepoUrl = sh(returnStdout: true, script: 'git config --get remote.origin.url').trim().replaceAll(/\.git$/, '')

                    lockResource = "env_${trimmedEnv}"
                }
            }
        }

        stage('Set Branch Name') {
            steps {
                script {
                    currentStage = env.STAGE_NAME
                    if (env.BRANCH_NAME.startsWith('PR')) {
                        gitBranchName = env.CHANGE_BRANCH
                    } else {
                        gitBranchName = env.BRANCH_NAME
                    }
                }
            }
        }

        stage('Destroy Server') {
            steps {
                warnError(message: "Error occurred during ${env.STAGE_NAME}", catchInterruptions: false) {
                    script {
                        currentStage = env.STAGE_NAME
                        try {
                            lock(resource: lockResource) {
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/server'
                                )
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/server/server-load '
                                )
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/server/server-regression'
                                )
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/server/insights/api-requests'
                                )
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            currentBuild.result = 'ABORTED'
                            sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                            throw e
                        }
                    }
                }
            }
        }

        stage('Destroy Pipeline') {
            steps {
                warnError(message: "Error occurred during ${env.STAGE_NAME}", catchInterruptions: false) {
                    script {
                        if (!bypassStageApproval) {
                            input "Approval is required before the pipeline may proceed"
                        }
                        currentStage = env.STAGE_NAME
                        try {
                            lock(resource: lockResource) {
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/pipeline'
                                )
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            currentBuild.result = 'ABORTED'
                            sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                            throw e
                        }
                    }
                }
            }
        }

        stage('Destroy Migrator') {
            steps {
                warnError(message: "Error occurred during ${env.STAGE_NAME}", catchInterruptions: false) {
                    script {
                        if (!bypassStageApproval) {
                            input "Approval is required before the pipeline may proceed"
                        }
                        currentStage = env.STAGE_NAME
                        try {
                            lock(resource: lockResource) {
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: "ops/terraform/services/migrator"
                                )
                            }
                            if (forceStageApproval) {
                                input "Approval is required before the pipeline may proceed"
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            currentBuild.result = 'ABORTED'
                            sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                            throw e
                        }
                    }
                }
            }
        }

        stage('Destroy Common') {
            steps {
                warnError(message: "Error occurred during ${env.STAGE_NAME}", catchInterruptions: false) {
                    script {
                        if (!bypassStageApproval) {
                            input "Approval is required before the pipeline may proceed"
                        }
                        currentStage = env.STAGE_NAME
                        try {
                            lock(resource: lockResource) {
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/common'
                                )
                            }
                            if (forceStageApproval) {
                                input "Approval is required before the pipeline may proceed"
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            currentBuild.result = 'ABORTED'
                            sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                            throw e
                        }
                    }
                }
            }
        }

        stage('Destroy Base') {
            steps {
                warnError(message: "Error occurred during ${env.STAGE_NAME}", catchInterruptions: false) {
                    script {
                        if (!bypassStageApproval) {
                            input "Approval is required before the pipeline may proceed"
                        }
                        currentStage = env.STAGE_NAME
                        try {
                            lock(resource: lockResource) {
                                awsAuth.assumeRole()
                                terraform.destroyTerraservice(
                                        env: trimmedEnv,
                                        directory: 'ops/terraform/services/base'
                                )
                            }
                        } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                            currentBuild.result = 'ABORTED'
                            sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                            throw e
                        } finally {
                            //sendNotifications(trimmedEnv, currentBuild.currentResult, currentStage, gitCommitId, gitRepoUrl)
                        }
                    }
                }
            }
        }

    }
}